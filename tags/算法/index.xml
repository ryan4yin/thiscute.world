<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>算法 - 标签 - Ryan4Yin's Space</title><link>https://ryan4yin.space/tags/%E7%AE%97%E6%B3%95/</link><description>算法 - 标签 - Ryan4Yin's Space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Tue, 03 Mar 2020 14:09:46 +0800</lastBuildDate><atom:link href="https://ryan4yin.space/tags/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>JWT 签名算法 HS256、RS256 及 ES256 及密钥生成</title><link>https://ryan4yin.space/jwt-algorithm-key-generation/</link><pubDate>Tue, 03 Mar 2020 14:09:46 +0800</pubDate><author>ryan4yin</author><guid>https://ryan4yin.space/jwt-algorithm-key-generation/</guid><description><![CDATA[<h1 id="签名算法">签名算法</h1>
<p>介绍具体的 JWT 签名算法前，先解释一下签名、摘要/指纹、加密这几个名词的含义：</p>
<ol>
<li>数字签名(Digital Signature):就和我们日常办理各种手续时需要在文件上签上自己的名字一样，数字签名的主要用途也是防止伪造签名。</li>
<li>数字摘要(digest)/数字指纹(fingerprint): 指的都是数据的 Hash 值。</li>
<li>加密算法：这个应该不需要解释，就是对数据进行加密。。</li>
</ol>
<p>数字签名的具体实现，通常是先对数据进行一次 Hash 摘要(SHA1/SHA256/SHA512 等)，然后再使用非对称加密算法(RSA/ECDSA 等)对这个摘要进行加密，这样得到的结果就是原始数据的一个签名。</p>
<p>用户在验证数据时，只需要使用公钥解密出 Hash 摘要，然后自己再对数据进行一次同样的摘要，对比两个摘要是否相同即可。</p>
<p>因为数字签名多了非对称加密这一步，就能保证只有拥有私钥的人才能生成出正确的数字签名，达到了防止伪造签名的目的。
而数字摘要（Hash）则谁都可以计算出来，通常<strong>由可信方公布数据的 Hash 值</strong>，用户下载数据后，可通过 Hash 值对比来判断数据是否损坏，或者被人调包。</p>
<p>重点在于，Hash 摘要必须由可信方公布出来，否则不能保证安全性。而数字签名可以随数据一起提供，不需要担心被伪造。</p>
<p>JWT 是签名和数据一起提供的，因此必须使用签名才能保证安全性。</p>
<blockquote>
<p>P.S. 在 Android/IOS 开发中，经常会遇到各类 API 或者 APP 商店要求提供 APP 的签名，还指明需要的是 MD5/SHA1 值。
这个地方需要填的 MD5/SHA1 值，实际上只是你「签名证书(=公钥+证书拥有者信息)」的「数字指纹/摘要」，和 JWT 的签名不是一回事。</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>JWT 规范的详细说明请见「参考」部分的链接。这里主要说明一下 JWT 最常见的几种签名算法(JWA)：HS256(HMAC-SHA256) 、RS256(RSA-SHA256) 还有 ES256(ECDSA-SHA256)。</p>
<p>这三种算法都是一种消息签名算法，得到的都只是一段无法还原的签名。区别在于<strong>消息签名</strong>与<strong>签名验证</strong>需要的 「key」不同。</p>
<ol>
<li>HS256 使用同一个「secret_key」进行签名与验证（对称加密）。一旦 secret_key 泄漏，就毫无安全性可言了。
<ul>
<li>因此 HS256 只适合集中式认证，签名和验证都必须由可信方进行。</li>
<li>传统的单体应用广泛使用这种算法，但是请不要在任何分布式的架构中使用它！</li>
</ul>
</li>
<li>RS256 是使用 RSA 私钥进行签名，使用 RSA 公钥进行验证。公钥即使泄漏也毫无影响，只要确保私钥安全就行。
<ul>
<li>RS256 可以将验证委托给其他应用，只要将公钥给他们就行。</li>
</ul>
</li>
<li>ES256 和 RS256 一样，都使用私钥签名，公钥验证。算法速度上差距也不大，但是它的签名长度相对短很多（省流量），并且算法强度和 RS256 差不多。</li>
</ol>
<p>对于单体应用而言，HS256 和 RS256 的安全性没有多大差别。
而对于需要进行多方验证的微服务架构而言，显然只有 RS256/ES256 才能提供足够的安全性。
在使用 RS256 时，只有「身份认证的微服务(auth)」需要用 RSA 私钥生成 JWT，其他微服务使用公开的公钥即可进行签名验证，私钥得到了更好的保护。</p>
<p>更进一步，「JWT 生成」和「JWT 公钥分发」都可以直接委托给第三方的通用工具，比如 <a href="https://github.com/ory/hydra" target="_blank" rel="noopener noreffer">hydra</a>。
甚至「JWT 验证」也可以委托给「API 网关」来处理，应用自身可以把认证鉴权完全委托给外部的平台，而应用自身只需要专注于业务。这也是目前的发展趋势。</p>
<p><a href="https://tools.ietf.org/html/rfc7518" target="_blank" rel="noopener noreffer">RFC 7518 - JSON Web Algorithms (JWA)</a> 中给出的 JWT 算法列表如下：</p>
<pre><code>+--------------+-------------------------------+--------------------+
| &quot;alg&quot; Param  | Digital Signature or MAC      | Implementation     |
| Value        | Algorithm                     | Requirements       |
+--------------+-------------------------------+--------------------+
| HS256        | HMAC using SHA-256            | Required           |
| HS384        | HMAC using SHA-384            | Optional           |
| HS512        | HMAC using SHA-512            | Optional           |
| RS256        | RSASSA-PKCS1-v1_5 using       | Recommended        |
|              | SHA-256                       |                    |
| RS384        | RSASSA-PKCS1-v1_5 using       | Optional           |
|              | SHA-384                       |                    |
| RS512        | RSASSA-PKCS1-v1_5 using       | Optional           |
|              | SHA-512                       |                    |
| ES256        | ECDSA using P-256 and SHA-256 | Recommended+       |
| ES384        | ECDSA using P-384 and SHA-384 | Optional           |
| ES512        | ECDSA using P-521 and SHA-512 | Optional           |
| PS256        | RSASSA-PSS using SHA-256 and  | Optional           |
|              | MGF1 with SHA-256             |                    |
| PS384        | RSASSA-PSS using SHA-384 and  | Optional           |
|              | MGF1 with SHA-384             |                    |
| PS512        | RSASSA-PSS using SHA-512 and  | Optional           |
|              | MGF1 with SHA-512             |                    |
| none         | No digital signature or MAC   | Optional           |
|              | performed                     |                    |
+--------------+-------------------------------+--------------------+

The use of &quot;+&quot; in the Implementation Requirements column indicates
that the requirement strength is likely to be increased in a future
version of the specification.
</code></pre>
<p>可以看到被标记为 <code>Recommended</code> 的只有 RS256 和 ES256。</p>
<p>ES256 使用 ECDSA 进行签名，它的安全性和运算速度目前和 RS256 差距不大，但是拥有更短的签名长度。
对于需要频繁发送的 JWT 而言，更短的长度长期下来可以节约大量流量。</p>
<p>因此更推荐使用 ES256 算法。</p>
<h2 id="使用-openssl-生成-rsaecc-公私钥">使用 OpenSSL 生成 RSA/ECC 公私钥</h2>
<p>RS256 使用 RSA 算法进行签名，可通过如下命令生成 RSA 密钥：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 1. 生成 2048 位（不是 256 位）的 RSA 密钥</span>
openssl genrsa -out rsa-private-key.pem <span class="m">2048</span>

<span class="c1"># 2. 通过密钥生成公钥</span>
openssl rsa -in rsa-private-key.pem -pubout -out rsa-public-key.pem
</code></pre></td></tr></table>
</div>
</div><p>ES256 使用 ECDSA 算法进行签名，该算法使用 ECC 密钥，生成命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 1. 生成 ec 算法的私钥，使用 prime256v1 算法，密钥长度 256 位。（强度大于 2048 位的 RSA 密钥）</span>
openssl ecparam -genkey -name prime256v1 -out ecc-private-key.pem
<span class="c1"># 2. 通过密钥生成公钥</span>
openssl ec -in ecc-private-key.pem -pubout -out ecc-public-key.pem
</code></pre></td></tr></table>
</div>
</div><p>密钥的使用应该就不需要介绍了，各类语言都有对应 JWT 库处理这些，请自行查看文档。</p>
<p>如果是调试/学习 JWT，需要手动签名与验证的话，推荐使用 <a href="https://jwt.io/" target="_blank" rel="noopener noreffer">jwt 工具网站 - jwt.io</a></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7518" target="_blank" rel="noopener noreffer">RFC 7518 - JSON Web Algorithms (JWA)</a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener noreffer">什么是 JWT &ndash; JSON WEB TOKEN</a></li>
<li><a href="https://jwt.io/" target="_blank" rel="noopener noreffer">jwt 工具网站 - jwt.io</a></li>
<li><a href="https://www.cnblogs.com/langshiquan/p/10701198.html" target="_blank" rel="noopener noreffer">JWT 算法比较</a></li>
</ul>
]]></description></item><item><title>欧几里得算法求最大公约数(GCD)的数学原理</title><link>https://ryan4yin.space/mathematics-in-euclidean-gcd/</link><pubDate>Fri, 26 May 2017 23:58:53 +0800</pubDate><author>ryan4yin</author><guid>https://ryan4yin.space/mathematics-in-euclidean-gcd/</guid><description><![CDATA[<p>很早就学过欧几里得算法，但是一直不知道它的原理。几乎每本算法书都会提到它，但是貌似只有数学书上才会见到它的原理。。。</p>
<p>前段时间粗粗看了点数论（《什么是数学》），惊讶于这个原理的奇妙。现在把它通俗地写下来，以免自己忘记。</p>
<p>欧几里得算法是求两个数的最大公约数(Greatest Common Divisor (GCD))的算法，我们首先假设<strong>有两个数 $a$ 和 $b$，其中 $a$ 是不小于 $b$ 的数</strong>，</p>
<p>记 $a$ 被 $b$ 除的余数为 $r$，那么 $a$ 可以写成这样的形式：</p>
<p>$$a = bq + r$$</p>
<p>其中 $q$ 是整数（我们不需要去管 $q$ 到底是多少，这和我们的目标无关）。</p>
<p>现在假设 $a$ 和 $b$ 的一个约数为 $u$，那么 $a$ 和 $b$ 都能被 $u$ 整除，即</p>
<p>$$a = su$$
$$b = tu$$</p>
<p>$s$ 和 $t$ 都是整数（同样的，我们只需要知道存在这样的整数 $s$ 和 $t$ 就行）。</p>
<p>这样可以得出</p>
<p>$$r = a - bq = su - (tu)q = (s - tq)u$$</p>
<p>所以 $r$ 也能被 $u$ 整除，一般规律如下</p>
<blockquote>
<p>$a$ 和 $b$ 的约数也整除它们的余数 $r$，所以 $a$ 和 $b$ 的任一约数同时也是 $b$ 和 $r$ 的约数。  —— 条件一</p>
</blockquote>
<p>反过来可以得出</p>
<blockquote>
<p>$b$ 和 $r$ 的任一约数同时也是 $a$ 和 $b$ 的约数。  ——条件二</p>
</blockquote>
<p>这是因为对 $b$ 和 $r$ 每一个约数 $v$，有</p>
<p>$$b = kv$$</p>
<p>$$r = cv$$</p>
<p>于是有</p>
<p>$$a = bq + r = (kv)q + cv = (kq + c)v$$</p>
<p>由条件一和条件二可知</p>
<blockquote>
<p>$a$ 和 $b$ 的约数的集合，全等于 $b$ 和 $r$ 的约数的集合。</p>
</blockquote>
<p>于是</p>
<blockquote>
<p>$a$ 和 $b$ 的最大公约数，就是 $b$ 和 $r$ 的最大公约数。</p>
</blockquote>
<p>接下来用递推法，</p>
<p>$a \div b$ 余 $r$，现在设</p>
<p>$b \div r$ 余 $r_1$</p>
<p>$r \div r_1$ 余 $r_2$</p>
<p>……</p>
<p>$r_{n-3} \div r_{n-2}$ 余 $r_{n-1}$</p>
<p>$r_{n-2} \div r_{n-1}$ 余 $r_n=0$</p>
</br>
<p>因为 $a \ge b$，可以看出余数 $r_n$ 会越来越小，最终变成 $0$.</p>
<p>当 $r_{n-1} \neq 0$ 且 $r_n = 0$ 时，可知 $r_{n-2}$ 可被 $r_{n-1}$ 整除（余数为 $0$ 嘛）</p>
<p>此时 $r_{n-2}$ 和 $r_{n-1}$ 的约数就只有：$r_{n-1}$ 和 $r_{n-1}$ 的因数，所以他们的最大公约数就是 $r_{n-1}$！</p>
<p>所以 $r_{n-1}$ 就是 $a$ 和 $b$ 的最大公约数。（若 $r = 0$，则 $b$ 为最大公约数）</p>
<p>这个递推法写成c语言函数是这样的（比推导更简洁&hellip;）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">Gcd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Rem</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">N</span><span class="p">){</span>
        <span class="n">Rem</span> <span class="o">=</span> <span class="n">M</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Rem</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Rem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以发现这里没有要求 <code>M&gt;=N</code>，这是因为如果那样，循环会自动交换它们的值。</p>
<blockquote>
<p>P.S. 此外，还有最小公倍数(Least Common Multiple (LCM))算法，详见 <a href="https://www.mathportal.org/calculators/numbers-calculators/gcd-lcm-calculator.php" target="_blank" rel="noopener noreffer">GCD and LCM calculator</a></p>
</blockquote>
]]></description></item></channel></rss>