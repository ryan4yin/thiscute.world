<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC - This Cute World</title><meta name=Description content="This Cute World"><meta property="og:title" content="写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC"><meta property="og:description" content="本文部分内容翻译自 Practical-Cryptography-for-Developers-Book，笔者补充了密码学历史以及 openssl 命令示例，"><meta property="og:type" content="article"><meta property="og:url" content="https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/"><meta property="og:image" content="https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-09T20:50:00+08:00"><meta property="article:modified_time" content="2022-03-13T15:26:00+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp"><meta name=twitter:title content="写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC"><meta name=twitter:description content="本文部分内容翻译自 Practical-Cryptography-for-Developers-Book，笔者补充了密码学历史以及 openssl 命令示例，"><meta name=application-name content="This Cute World"><meta name=apple-mobile-web-app-title content="This Cute World"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/><link rel=prev href=https://thiscute.world/posts/practical-cryptography-basics-6-symmetric-key-ciphers/><link rel=next href=https://thiscute.world/posts/about-tls-cert/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><meta name=google-site-verification content="E8bpp1lVVlb9YnSJcUzPL1dLAG17Nl_sp5Ru9a8tUDQ"><meta name=baidu-site-verification content="code-ZZtDruAnX1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/thiscute.world\/posts\/practical-cryptography-basics-7-asymmetric-key-ciphers\/"},"image":[{"@type":"ImageObject","url":"https:\/\/thiscute.world\/posts\/practical-cryptography-basics-7-asymmetric-key-ciphers\/symmetric-vs-asymmetric.webp","width":909,"height":287}],"genre":"posts","keywords":"Cryptography, 密码学, 非对称加密, 安全, RSA, ECC","wordcount":13920,"url":"https:\/\/thiscute.world\/posts\/practical-cryptography-basics-7-asymmetric-key-ciphers\/","datePublished":"2022-03-09T20:50:00+08:00","dateModified":"2022-03-13T15:26:00+08:00","publisher":{"@type":"Organization","name":"ryan4yin","logo":"https:\/\/thiscute.world\/avatar\/myself.png"},"author":{"@type":"Person","name":"ryan4yin"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark")}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="This Cute World"><span id=desktop-header-typeit class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/statistics/>阅读排行 </a><a class=menu-item href=/categories/tech/>技术 </a><a class=menu-item href=/categories/life/>生活 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/friends/>朋友们 </a><a class=menu-item href=/now/>此刻 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item language" title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title="Select Language" id=language-select-desktop onchange="location=this.value"><option value=/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/ selected>Simplified Chinese</option></select>
</a><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# onclick=return!1 class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# onclick=return!1 class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=# onclick=return!1 class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="This Cute World"><span id=mobile-header-typeit class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# onclick=return!1 class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# onclick=return!1 class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# onclick=return!1 class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/statistics/ title>阅读排行</a><a class=menu-item href=/categories/tech/ title>技术</a><a class=menu-item href=/categories/life/ title>生活</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/friends/ title>朋友们</a><a class=menu-item href=/now/ title>此刻</a><a class=menu-item href=/about/ title>关于</a><a href=# onclick=return!1 class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a><a href=# onclick=return!1 class=menu-item title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title="Select Language" onchange="location=this.value"><option value=/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/ selected>Simplified Chinese</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#一公钥密码学--非对称密码学>一、公钥密码学 / 非对称密码学</a><ul><li><a href=#密码学的历史>密码学的历史</a></li><li><a href=#公钥密码学的概念>公钥密码学的概念</a></li><li><a href=#量子安全性>量子安全性</a></li></ul></li><li><a href=#二非对称加密方案简介>二、非对称加密方案简介</a><ul><li><a href=#1-密钥封装机制-kem>1. 密钥封装机制 KEM</a><ul><li><a href=#密钥封装key-encapsulation与密钥包裹key-wrapping>密钥封装（Key encapsulation）与密钥包裹（Key wrapping）</a></li></ul></li><li><a href=#2-集成加密方案-ies>2. 集成加密方案 IES</a></li></ul></li><li><a href=#三rsa-密码系统>三、RSA 密码系统</a><ul><li><a href=#rsa-密钥对生成>RSA 密钥对生成</a></li><li><a href=#rsa-加密与解密>RSA 加密与解密</a><ul><li><a href=#rsa-解密运算的证明>RSA 解密运算的证明</a></li></ul></li><li><a href=#rsa-数字签名>RSA 数字签名</a></li></ul></li><li><a href=#四ecc-密码系统>四、ECC 密码系统</a><ul><li><a href=#椭圆曲线的数学原理简介>椭圆曲线的数学原理简介</a><ul><li><a href=#椭圆曲线上的运算>椭圆曲线上的运算</a><ul><li><a href=#1-加法与负元>1. 加法与负元</a></li><li><a href=#2-二倍运算>2. 二倍运算</a></li><li><a href=#3-无穷远点>3. 无穷远点</a></li><li><a href=#4-k-倍运算>4. k 倍运算</a></li></ul></li><li><a href=#5-有限域上的椭圆曲线>5. 有限域上的椭圆曲线</a></li><li><a href=#ecdlp-椭圆曲线离散对数问题>ECDLP 椭圆曲线离散对数问题</a></li></ul></li><li><a href=#ecc-密钥对生成>ECC 密钥对生成</a></li><li><a href=#ecdh-密钥交换>ECDH 密钥交换</a></li><li><a href=#ecc-加密与解密>ECC 加密与解密</a></li><li><a href=#ecc-数字签名>ECC 数字签名</a><ul><li><a href=#eddsa-与-ed25519-签名算法>EdDSA 与 Ed25519 签名算法</a></li></ul></li><li><a href=#密码学常用椭圆曲线介绍>密码学常用椭圆曲线介绍</a><ul><li><a href=#生成点-g>生成点 G</a></li><li><a href=#椭圆曲线的域参数>椭圆曲线的域参数</a><ul><li><a href=#secp256k1>secp256k1</a></li><li><a href=#edwards-曲线>Edwards 曲线</a></li><li><a href=#curve25519-x25519-和-ed25519>Curve25519, X25519 和 Ed25519</a></li><li><a href=#curve448-x448-和-ed448>Curve448, X448 和 Ed448</a></li><li><a href=#该选择哪种椭圆曲线>该选择哪种椭圆曲线</a></li></ul></li></ul></li><li><a href=#ecies---集成加密方案>ECIES - 集成加密方案</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=https://thiscute.world/ title=Author target=_blank rel="noopener noreferrer author" class=author>ryan4yin</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-09>2022-03-09</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-03-13>2022-03-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 13920 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 28 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload data-src=/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp data-srcset="/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp, /posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp 1.5x, /posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp 2x" data-sizes=auto alt=/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp title=/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp height=287 width=909></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#一公钥密码学--非对称密码学>一、公钥密码学 / 非对称密码学</a><ul><li><a href=#密码学的历史>密码学的历史</a></li><li><a href=#公钥密码学的概念>公钥密码学的概念</a></li><li><a href=#量子安全性>量子安全性</a></li></ul></li><li><a href=#二非对称加密方案简介>二、非对称加密方案简介</a><ul><li><a href=#1-密钥封装机制-kem>1. 密钥封装机制 KEM</a><ul><li><a href=#密钥封装key-encapsulation与密钥包裹key-wrapping>密钥封装（Key encapsulation）与密钥包裹（Key wrapping）</a></li></ul></li><li><a href=#2-集成加密方案-ies>2. 集成加密方案 IES</a></li></ul></li><li><a href=#三rsa-密码系统>三、RSA 密码系统</a><ul><li><a href=#rsa-密钥对生成>RSA 密钥对生成</a></li><li><a href=#rsa-加密与解密>RSA 加密与解密</a><ul><li><a href=#rsa-解密运算的证明>RSA 解密运算的证明</a></li></ul></li><li><a href=#rsa-数字签名>RSA 数字签名</a></li></ul></li><li><a href=#四ecc-密码系统>四、ECC 密码系统</a><ul><li><a href=#椭圆曲线的数学原理简介>椭圆曲线的数学原理简介</a><ul><li><a href=#椭圆曲线上的运算>椭圆曲线上的运算</a><ul><li><a href=#1-加法与负元>1. 加法与负元</a></li><li><a href=#2-二倍运算>2. 二倍运算</a></li><li><a href=#3-无穷远点>3. 无穷远点</a></li><li><a href=#4-k-倍运算>4. k 倍运算</a></li></ul></li><li><a href=#5-有限域上的椭圆曲线>5. 有限域上的椭圆曲线</a></li><li><a href=#ecdlp-椭圆曲线离散对数问题>ECDLP 椭圆曲线离散对数问题</a></li></ul></li><li><a href=#ecc-密钥对生成>ECC 密钥对生成</a></li><li><a href=#ecdh-密钥交换>ECDH 密钥交换</a></li><li><a href=#ecc-加密与解密>ECC 加密与解密</a></li><li><a href=#ecc-数字签名>ECC 数字签名</a><ul><li><a href=#eddsa-与-ed25519-签名算法>EdDSA 与 Ed25519 签名算法</a></li></ul></li><li><a href=#密码学常用椭圆曲线介绍>密码学常用椭圆曲线介绍</a><ul><li><a href=#生成点-g>生成点 G</a></li><li><a href=#椭圆曲线的域参数>椭圆曲线的域参数</a><ul><li><a href=#secp256k1>secp256k1</a></li><li><a href=#edwards-曲线>Edwards 曲线</a></li><li><a href=#curve25519-x25519-和-ed25519>Curve25519, X25519 和 Ed25519</a></li><li><a href=#curve448-x448-和-ed448>Curve448, X448 和 Ed448</a></li><li><a href=#该选择哪种椭圆曲线>该选择哪种椭圆曲线</a></li></ul></li></ul></li><li><a href=#ecies---集成加密方案>ECIES - 集成加密方案</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>本文部分内容翻译自 <a href=https://github.com/nakov/Practical-Cryptography-for-Developers-Book target=_blank rel="noopener noreferrer">Practical-Cryptography-for-Developers-Book</a>，笔者补充了密码学历史以及 openssl 命令示例，并重写了 RSA/ECC 算法原理、代码示例等内容。</p></blockquote><blockquote><p>这篇文章中会涉及到一些数论知识，本文不会详细介绍这些数学知识，可以在有疑惑的时候自行查找相关知识，或者选择跳过相关内容。</p></blockquote><p>《写给开发人员的实用密码学》系列文章目录：</p><ul><li><a href=/posts/practical-cryptography-basics-1/ rel>写给开发人员的实用密码学（一）—— 概览</a></li><li><a href=/posts/practical-cryptography-basics-2-hash/ rel>写给开发人员的实用密码学（二）—— 哈希函数</a></li><li><a href=/posts/practical-cryptography-basics-3-key-derivation-function/ rel>写给开发人员的实用密码学（三）—— MAC 与密钥派生函数 KDF</a></li><li><a href=/posts/practical-cryptography-basics-4-secure-random-generators/ rel>写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li><li><a href=/posts/practical-cryptography-basics-5-key-exchange/ rel>写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a></li><li><a href=/posts/practical-cryptography-basics-6-symmetric-key-ciphers/ rel>写给开发人员的实用密码学（六）—— 对称密钥加密算法</a></li><li><a href=/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/ rel>写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</a></li><li><a href=/posts/about-tls-cert rel>写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a></li><li>待续</li></ul><h2 id=一公钥密码学--非对称密码学 class=headerLink><a href=#%e4%b8%80%e5%85%ac%e9%92%a5%e5%af%86%e7%a0%81%e5%ad%a6--%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%af%86%e7%a0%81%e5%ad%a6 class=header-mark></a>一、公钥密码学 / 非对称密码学</h2><p>在介绍非对称密钥加密方案和算法之前，我们首先要了解公钥密码学的概念。</p><h3 id=密码学的历史 class=headerLink><a href=#%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e5%8e%86%e5%8f%b2 class=header-mark></a>密码学的历史</h3><p>从第一次世界大战、第二次世界大战到 1976 年这段时期密码的发展阶段，被称为「近代密码阶段」。
在近代密码阶段，所有的密码系统都使用对称密码算法——使用相同的密钥进行加解密。
当时使用的密码算法在拥有海量计算资源的现代人看来都是非常简单的，我们经常看到各种讲述一二战的谍战片，基本都包含破译电报的片段。</p><p>第一二次世界大战期间，无线电被广泛应用于军事通讯，围绕无线电通讯的加密破解攻防战极大地影响了战局。</p><p>公元20世纪初，第一次世界大战进行到关键时刻，英国破译密码的专门机构「40号房间」利用缴获的德国密码本破译了著名的「齐默尔曼电报」，其内容显示德国打算联合墨西哥对抗可能会参战的美国，这促使美国放弃中立对德宣战，从而彻底改变了一战的走势。</p><p>1943 年，美国从破译的日本电报中得知山本五十六将于 4 月 18 日乘中型轰炸机，由 6 架战斗机护航，到中途岛视察。美国总统罗斯福亲自做出决定截击山本，山本乘坐的飞机在去往中途岛的路上被美军击毁，战争天才山本五十六机毁人亡，日本海军从此一蹶不振。</p><p>此外，在二次世界大战中，美军将印第安纳瓦霍土著语言作为密码使用，并特别征募使用印第安纳瓦霍通信兵。在二次世界大战日美的太平洋战场上，美国海军军部让北墨西哥和亚历桑那印第安纳瓦霍族人使用纳瓦霍语进行情报传递。纳瓦霍语的语法、音调及词汇都极为独特，不为世人所知道，当时纳瓦霍族以外的美国人中，能听懂这种语言的也就一二十人。这是<strong>密码学</strong>和<strong>语言学</strong>的成功结合，纳瓦霍语密码成为历史上从未被破译的密码。</p><p>在 1976 年 Malcolm J. Williamson 公开发表了现在被称为「Diffie–Hellman 密钥交换，DHKE」的算法，并提出了「公钥密码学」的概念，这是密码学领域一项划时代的发明，它宣告了「近代密码阶段」的终结，是「现代密码学」的起点。</p><p>言归正传，对称密码算法的问题有两点：</p><ul><li>「<strong>需要安全的通道进行密钥交换</strong>」，早期最常见的是面对面交换密钥</li><li>每个点对点通信都需要使用不同的密钥，<strong>密钥的管理会变得很困难</strong><ul><li>如果你需要跟 100 个朋友安全通信，你就要维护 100 个不同的对称密钥，而且还得确保它们不泄漏。</li></ul></li></ul><p>这会导致巨大的「密钥交换」跟「密钥保存与管理」的成本。「公钥密码学」最大的优势就是，它解决了这两个问题：</p><ul><li>「公钥密码学」可以在<strong>不安全的信道</strong>上安全地进行密钥交换，第三方即使监听到通信过程，但是（几乎）无法破解出密钥。</li><li>每个人只需要公开自己的公钥，就可以跟其他任何人安全地通信。<ul><li>如果你需要跟 100 个朋友安全通信，你们只需要公开自己的公钥。发送消息时使用对方的公钥加密，接收消息时使用自己的私钥解密即可。</li><li>只有你自己的私钥需要保密，所有的公钥都可以公开，这就显著降低了密钥的维护成本。</li></ul></li></ul><p>因此公钥密码学成为了现代密码学的基石，而「公钥密码学」的诞生时间 1976 年被认为是现代密码学的开端。</p><h3 id=公钥密码学的概念 class=headerLink><a href=#%e5%85%ac%e9%92%a5%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e6%a6%82%e5%bf%b5 class=header-mark></a>公钥密码学的概念</h3><p>公钥密码系统的密钥始终以公钥 + 私钥对的形式出现，公钥密码系统提供数学框架和算法来生成公钥+私钥对。
公钥通常与所有人共享，而私钥则保密。
公钥密码系统在设计时就确保了在预期的算力下，几乎不可能从其公开的公钥逆向演算出对应的私钥。</p><p>公钥密码系统主要有三大用途：<strong>加密与解密、签名与验证、密钥交换</strong>。
每种算法都需要使用到公钥和私钥，比如由公钥加密的消息只能由私钥解密，由私钥签名的消息需要用公钥验证。</p><p>由于加密解密、签名验证均需要两个不同的密钥，故「公钥密码学」也被称为「<strong>非对称密码学</strong>」。</p><p>比较著名的公钥密码系统有：RSA、ECC（椭圆曲线密码学）、ElGamal、Diffie-Hellman、ECDH、ECDSA 和 EdDSA。许多密码算法都是以这些密码系统为基础实现的，例如 RSA 签名、RSA 加密/解密、ECDH 密钥交换以及 ECDSA 和 EdDSA 签名。</p><h3 id=量子安全性 class=headerLink><a href=#%e9%87%8f%e5%ad%90%e5%ae%89%e5%85%a8%e6%80%a7 class=header-mark></a>量子安全性</h3><blockquote><p>参考文档：https://en.wikipedia.org/wiki/Post-quantum_cryptography</p></blockquote><p>目前流行的公钥密码系统基本都依赖于 IFP（整数分解问题）、DLP（离散对数问题）或者 ECDLP（椭圆曲线离散对数问题），这导致这些算法都是<strong>量子不安全</strong>（quantum-unsafe）的。</p><p>如果人类进入量子时代，IFP / DLP / ECDLP 的难度将大大降低，目前流行的 RSA、ECC、ElGamal、Diffie-Hellman、ECDH、ECDSA 和 EdDSA 等公钥密码算法都将被淘汰。</p><p>目前已经有一些量子安全的公钥密码系统问世，但是因为它们需要更长的密钥、更长的签名等原因，目前还未被广泛使用。</p><p>一些量子安全的公钥密码算法举例：NewHope、NTRU、GLYPH、BLISS、XMSS、<a href=https://github.com/Microsoft/Picnic target=_blank rel="noopener noreferrer">Picnic</a> 等，有兴趣的可以自行搜索相关文档。</p><h2 id=二非对称加密方案简介 class=headerLink><a href=#%e4%ba%8c%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88%e7%ae%80%e4%bb%8b class=header-mark></a>二、非对称加密方案简介</h2><p>非对称加密要比对称加密复杂，有如下几个原因：</p><ul><li>使用密钥对进行加解密，导致其算法更为复杂</li><li>只能加密/解密很短的消息<ul><li>在 RSA 系统中，输入消息需要被转换为大整数（例如使用 OAEP 填充），然后才能被加密为密文。（密文实质上就是另一个大整数）</li></ul></li><li>一些非对称密码系统（如 ECC）不直接提供加密能力，需要结合使用更复杂的方案才能实现加解密</li></ul><p>此外，非对称密码比对称密码慢非常多。比如 RSA 加密比 AES 慢 1000 倍，跟 ChaCha20 就更没法比了。</p><p>为了解决上面提到的这些困难并支持加密任意长度的消息，现代密码学使用「<strong>非对称加密方案</strong>」来实现消息加解密。
又因为「对称加密方案」具有速度快、支持加密任意长度消息等特性，「非对称加密方案」通常直接直接组合使用<strong>对称加密算法</strong>与<strong>非对称加密算法</strong>。比如「密钥封装机制 KEM（key encapsulation mechanisms)）」与「集成加密方案 IES（Integrated Encryption Scheme）」</p><h3 id=1-密钥封装机制-kem class=headerLink><a href=#1-%e5%af%86%e9%92%a5%e5%b0%81%e8%a3%85%e6%9c%ba%e5%88%b6-kem class=header-mark></a>1. 密钥封装机制 KEM</h3><p>顾名思义，KEM 就是仅使用非对称加密算法加密另一个密钥，实际数据的加解密由该密钥完成。</p><p>密钥封装机制 KEM 的加密流程（使用公钥加密传输对称密钥）：</p><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/hybrid-encryption.webp></figure><p>密钥封装机制 KEM 的解密流程（使用私钥解密出对称密钥，然后再使用这个对称密钥解密数据）：</p><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/hybrid-decryption.webp></figure><p>RSA-OAEP, RSA-KEM, ECIES-KEM 和 PSEC-KEM. 都是 KEM 加密方案。</p><h4 id=密钥封装key-encapsulation与密钥包裹key-wrapping class=headerLink><a href=#%e5%af%86%e9%92%a5%e5%b0%81%e8%a3%85key-encapsulation%e4%b8%8e%e5%af%86%e9%92%a5%e5%8c%85%e8%a3%b9key-wrapping class=header-mark></a>密钥封装（Key encapsulation）与密钥包裹（Key wrapping）</h4><p>主要区别在于使用的是对称加密算法、还是非对称加密算法：</p><ul><li>密钥封装（Key encapsulation）指使用非对称密码算法的公钥加密另一个密钥。</li><li>密钥包裹（Key wrapping）指使用对称密码算法加密另一个密钥。</li></ul><h3 id=2-集成加密方案-ies class=headerLink><a href=#2-%e9%9b%86%e6%88%90%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88-ies class=header-mark></a>2. 集成加密方案 IES</h3><p>集成加密方案 (IES) 在密钥封装机制（KEM）的基础上，添加了密钥派生算法 KDF、消息认证算法 MAC 等其他密码学算法以达成更高的安全性。</p><p>在 IES 方案中，非对称算法（如 RSA 或 ECC）跟 KEM 一样，都是用于加密或封装对称密钥，然后通过对称密钥（如 AES 或 Chacha20）来加密输入消息。</p><p>DLIES（离散对数集成加密方案）和 ECIES（椭圆曲线集成加密方案）都是 IES 方案。</p><h2 id=三rsa-密码系统 class=headerLink><a href=#%e4%b8%89rsa-%e5%af%86%e7%a0%81%e7%b3%bb%e7%bb%9f class=header-mark></a>三、RSA 密码系统</h2><p>RSA 密码系统是最早的公钥密码系统之一，它基于 <a href=https://en.wikipedia.org/wiki/RSA_problem target=_blank rel="noopener noreferrer">RSA 问题</a>和<a href=https://en.wikipedia.org/wiki/Integer_factorization target=_blank rel="noopener noreferrer">整数分解问题 （IFP）</a>的计算难度。
RSA 算法以其作者（Rivest–Shamir–Adleman）的首字母命名。</p><p>RSA 算法在计算机密码学的早期被广泛使用，至今仍然是数字世界应用最广泛的密码算法。
但是随着 ECC 密码学的发展，ECC 正在非对称密码系统中慢慢占据主导地位，因为它比 RSA 具有更高的安全性和更短的密钥长度。</p><p>RSA 算法提供如下几种功能：</p><ul><li>密钥对生成：生成随机私钥（通常大小为 1024-4096 位）和相应的公钥。</li><li>加密解密：使用公钥加密消息（消息要先转换为 [0&mldr;key_length] 范围内的整数），然后使用密钥解密。</li><li>数字签名：签署消息（使用私钥）和验证消息签名（使用公钥）。<ul><li>数字签名实际上是通过 Hash 算法 + 加密解密功能实现的。后面会介绍到，它与一般加解密流程的区别，在于数字签名使用私钥加密，再使用公钥解密。</li></ul></li><li>密钥交换：安全地传输密钥，用于以后的加密通信。</li></ul><p>RSA 可以使用不同长度的密钥：1024、2048、3072、4096、8129、16384 甚至更多位。目前 <strong>3072</strong> 位及以上的密钥长度被认为是安全的，曾经大量使用的 <strong>2048</strong> 位 RSA 现在被破解的风险在不断提升，已经不推荐使用了。</p><p>更长的密钥提供更高的安全性，但会消耗更多的计算时间，同时签名也会变得更长，因此需要在安全性和速度之间进行权衡。
非常长的 RSA 密钥（例如 50000 位或 65536 位）对于实际使用可能太慢，例如密钥生成可能需要几分钟到几个小时。</p><h3 id=rsa-密钥对生成 class=headerLink><a href=#rsa-%e5%af%86%e9%92%a5%e5%af%b9%e7%94%9f%e6%88%90 class=header-mark></a>RSA 密钥对生成</h3><p>RSA 密钥对的生成跟我们在本系列文章的第 5 篇介绍的「DHKE 密钥交换算法」会有些类似，但是要更复杂一点。</p><p>首先看下我们怎么使用 openssl 生成一个 1024 位的 RSA 密钥对（<strong>仅用做演示，实际应用中建议 3072 位</strong>）：</p><blockquote><p><a href=https://github.com/openssl/openssl target=_blank rel="noopener noreferrer">OpenSSL</a> 是目前使用最广泛的网络加密算法库，支持非常多流行的现代密码学算法，几乎所有操作系统都会内置 openssl.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 生成 1024 位的 RSA 私钥
</span></span><span class=line><span class=cl>❯ openssl genrsa -out rsa-private-key.pem 1024
</span></span><span class=line><span class=cl>Generating RSA private key, 1024 bit long modulus
</span></span><span class=line><span class=cl>.................+++
</span></span><span class=line><span class=cl>.....+++
</span></span><span class=line><span class=cl>e is 65537 (0x10001)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 使用私钥生成对应的公钥文件
</span></span><span class=line><span class=cl>❯ openssl rsa -in rsa-private-key.pem -pubout -out rsa-public-key.pem
</span></span><span class=line><span class=cl>writing RSA key
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 查看私钥内容
</span></span><span class=line><span class=cl>❯ cat rsa-private-key.pem
</span></span><span class=line><span class=cl>-----BEGIN RSA PRIVATE KEY-----
</span></span><span class=line><span class=cl>MIICXAIBAAKBgQDNE8QZLJZXREOeWZ2ilAzGC4Kjq/PfsFzrXGj8g3IaS4/J3JrB
</span></span><span class=line><span class=cl>o3qEq/k9XoRzOmNPyvWCj2FAY7A099d7qX4ztthBpUM2ePDIYDvhL0EpfQqbhe+Q
</span></span><span class=line><span class=cl>aagcFpuKTshGR2wBjH0Cl1/WxJkfIUMmWYU+m4iKLw9KfLX6BjmSgWB6HQIDAQAB
</span></span><span class=line><span class=cl>AoGADb5NXgKG8MI6ZdpLniGd2Yfb8WwMo+kF0SAYSRPmCa0WrciC9ocmJs3/ngU/
</span></span><span class=line><span class=cl>ixlWnnpTibRiKBaGMIaLglYRhvbvibUo8PH4woIidTho2e6swF2aqILk6YFJDpxX
</span></span><span class=line><span class=cl>FCFdbXM4Cm2MqbD4VtmhCYqbvuiyEUci83YrRP0jJGNt0GECQQDyZgdi8JlFQFH8
</span></span><span class=line><span class=cl>1QRHjLN57v5bHQamv7Qb77hlbdbg1wTYO+H8tsOB181TEHA7uN8hxkzyYZy+goRx
</span></span><span class=line><span class=cl>n0hvJcQXAkEA2JWhCb7oG1eal1aUdgofxhlWnkoFeWHay2zgDWSqmGKyDt0Cb1jq
</span></span><span class=line><span class=cl>XTdN9dchnqfptWN2/QPLDgM+/9g39/zv6wJATC1sXNeoE29nVMHNGn9JWCSXoyK4
</span></span><span class=line><span class=cl>GGdevvjTRm0Cfp6UUzBekQEO6Btd16Du5JXw6bhcLkAm9mgmH18jcGq5+QJBALnr
</span></span><span class=line><span class=cl>aDv3d0PRZdE372WMt03UfniOzjgueiVaJtMYcSEyx+reabKvvy+ZxACfVirdtU+S
</span></span><span class=line><span class=cl>PJhhYzN6MeBp+VGV/VUCQBXz0LyM08roWi6DiaRwJIbYx+WCKEOGXQ9QsZND+sGr
</span></span><span class=line><span class=cl>pOpugr3mcUge5dcZGKtsOUx2xRVmg88nSWMQVkTlsjQ=
</span></span><span class=line><span class=cl>-----END RSA PRIVATE KEY-----
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 查看私钥的详细参数
</span></span><span class=line><span class=cl>❯ openssl rsa -noout -text -in rsa-private-key.pem
</span></span><span class=line><span class=cl>Private-Key: (1024 bit)
</span></span><span class=line><span class=cl>modulus:
</span></span><span class=line><span class=cl>    00💿13:c4:19:2c:96:57:44:43:9e:59:9d:a2:94:
</span></span><span class=line><span class=cl>    0c:c6:0b:82:a3🆎f3:df:b0:5c:eb:5c:68:fc:83:
</span></span><span class=line><span class=cl>    72:1a:4b:8f:c9:dc:9a:c1:a3:7a:84🆎f9:3d:5e:
</span></span><span class=line><span class=cl>    84:73:3a:63:4f:ca:f5:82:8f:61:40:63:b0:34:f7:
</span></span><span class=line><span class=cl>    d7:7b:a9:7e:33:b6:d8:41:a5:43:36:78:f0:c8:60:
</span></span><span class=line><span class=cl>    3b:e1:2f:41:29:7d:0a:9b:85:ef:90:69:a8:1c:16:
</span></span><span class=line><span class=cl>    9b:8a:4e:c8:46:47:6c:01:8c:7d:02:97:5f:d6:c4:
</span></span><span class=line><span class=cl>    99:1f:21:43:26:59:85:3e:9b:88:8a:2f:0f:4a:7c:
</span></span><span class=line><span class=cl>    b5:fa:06:39:92:81:60:7a:1d
</span></span><span class=line><span class=cl>publicExponent: 65537 (0x10001)
</span></span><span class=line><span class=cl>privateExponent:
</span></span><span class=line><span class=cl>    0d:be:4d:5e:02:86:f0:c2:3a:65:da:4b:9e:21:9d:
</span></span><span class=line><span class=cl>    d9:87:db:f1:6c:0c:a3:e9:05:d1:20:18:49:13:e6:
</span></span><span class=line><span class=cl>    09:ad:16:ad:c8:82:f6:87:26:26:cd:ff:9e:05:3f:
</span></span><span class=line><span class=cl>    8b:19:56:9e:7a:53:89:b4:62:28:16:86:30:86:8b:
</span></span><span class=line><span class=cl>    82:56:11:86:f6:ef:89:b5:28:f0:f1:f8:c2:82:22:
</span></span><span class=line><span class=cl>    75:38:68:d9:ee:ac:c0:5d:9a:a8:82:e4:e9:81:49:
</span></span><span class=line><span class=cl>    0e:9c:57:14:21:5d:6d:73:38:0a:6d:8c:a9:b0:f8:
</span></span><span class=line><span class=cl>    56:d9:a1:09:8a:9b:be:e8:b2:11:47:22:f3:76:2b:
</span></span><span class=line><span class=cl>    44:fd:23:24:63:6d:d0:61
</span></span><span class=line><span class=cl>prime1:
</span></span><span class=line><span class=cl>    00:f2:66:07:62:f0:99:45:40:51:fc:d5:04:47:8c:
</span></span><span class=line><span class=cl>    b3:79:ee:fe:5b:1d:06:a6:bf:b4:1b:ef:b8:65:6d:
</span></span><span class=line><span class=cl>    d6:e0:d7:04:d8:3b:e1:fc:b6:c3:81:d7:cd:53:10:
</span></span><span class=line><span class=cl>    70:3b:b8:df:21:c6:4c:f2:61:9c:be:82:84:71:9f:
</span></span><span class=line><span class=cl>    48:6f:25:c4:17
</span></span><span class=line><span class=cl>prime2:
</span></span><span class=line><span class=cl>    00:d8:95:a1:09:be:e8:1b:57:9a:97:56:94:76:0a:
</span></span><span class=line><span class=cl>    1f:c6:19:56:9e:4a:05:79:61:da:cb:6c:e0:0d:64:
</span></span><span class=line><span class=cl>    aa:98:62:b2:0e:dd:02:6f:58:ea:5d:37:4d:f5:d7:
</span></span><span class=line><span class=cl>    21:9e:a7:e9:b5:63:76:fd:03:cb:0e:03:3e:ff:d8:
</span></span><span class=line><span class=cl>    37:f7:fc:ef:eb
</span></span><span class=line><span class=cl>exponent1:
</span></span><span class=line><span class=cl>    4c:2d:6c:5c:d7:a8:13:6f:67:54:c1💿1a:7f:49:
</span></span><span class=line><span class=cl>    58:24:97:a3:22:b8:18:67:5e:be:f8:d3:46:6d:02:
</span></span><span class=line><span class=cl>    7e:9e:94:53:30:5e:91:01:0e:e8:1b:5d:d7:a0:ee:
</span></span><span class=line><span class=cl>    e4:95:f0:e9:b8:5c:2e:40:26:f6:68:26:1f:5f:23:
</span></span><span class=line><span class=cl>    70:6a:b9:f9
</span></span><span class=line><span class=cl>exponent2:
</span></span><span class=line><span class=cl>    00:b9:eb:68:3b:f7:77:43:d1:65:d1:37:ef:65:8c:
</span></span><span class=line><span class=cl>    b7:4d:d4:7e:78:8e:ce:38:2e:7a:25:5a:26:d3:18:
</span></span><span class=line><span class=cl>    71:21:32:c7:ea🇩🇪69:b2:af:bf:2f:99:c4:00:9f:
</span></span><span class=line><span class=cl>    56:2a:dd:b5:4f:92:3c:98:61:63:33:7a:31:e0:69:
</span></span><span class=line><span class=cl>    f9:51:95:fd:55
</span></span><span class=line><span class=cl>coefficient:
</span></span><span class=line><span class=cl>    15:f3:d0:bc:8c:d3:ca:e8:5a:2e:83:89:a4:70:24:
</span></span><span class=line><span class=cl>    86:d8:c7:e5:82:28:43:86:5d:0f:50:b1:93:43:fa:
</span></span><span class=line><span class=cl>    c1🆎a4:ea:6e:82:bd:e6:71:48:1e:e5:d7:19:18:
</span></span><span class=line><span class=cl>    ab:6c:39:4c:76:c5:15:66:83:cf:27:49:63:10:56:
</span></span><span class=line><span class=cl>    44:e5:b2:34
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 查看私钥内容
</span></span><span class=line><span class=cl>❯ cat rsa-public-key.pem 
</span></span><span class=line><span class=cl>-----BEGIN PUBLIC KEY-----
</span></span><span class=line><span class=cl>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDNE8QZLJZXREOeWZ2ilAzGC4Kj
</span></span><span class=line><span class=cl>q/PfsFzrXGj8g3IaS4/J3JrBo3qEq/k9XoRzOmNPyvWCj2FAY7A099d7qX4ztthB
</span></span><span class=line><span class=cl>pUM2ePDIYDvhL0EpfQqbhe+QaagcFpuKTshGR2wBjH0Cl1/WxJkfIUMmWYU+m4iK
</span></span><span class=line><span class=cl>Lw9KfLX6BjmSgWB6HQIDAQAB
</span></span><span class=line><span class=cl>-----END PUBLIC KEY-----
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 查看公钥的参数
</span></span><span class=line><span class=cl>❯ openssl rsa -noout -text -pubin -in rsa-public-key.pem
</span></span><span class=line><span class=cl>Public-Key: (1024 bit)
</span></span><span class=line><span class=cl>Modulus:
</span></span><span class=line><span class=cl>    00💿13:c4:19:2c:96:57:44:43:9e:59:9d:a2:94:
</span></span><span class=line><span class=cl>    0c:c6:0b:82:a3🆎f3:df:b0:5c:eb:5c:68:fc:83:
</span></span><span class=line><span class=cl>    72:1a:4b:8f:c9:dc:9a:c1:a3:7a:84🆎f9:3d:5e:
</span></span><span class=line><span class=cl>    84:73:3a:63:4f:ca:f5:82:8f:61:40:63:b0:34:f7:
</span></span><span class=line><span class=cl>    d7:7b:a9:7e:33:b6:d8:41:a5:43:36:78:f0:c8:60:
</span></span><span class=line><span class=cl>    3b:e1:2f:41:29:7d:0a:9b:85:ef:90:69:a8:1c:16:
</span></span><span class=line><span class=cl>    9b:8a:4e:c8:46:47:6c:01:8c:7d:02:97:5f:d6:c4:
</span></span><span class=line><span class=cl>    99:1f:21:43:26:59:85:3e:9b:88:8a:2f:0f:4a:7c:
</span></span><span class=line><span class=cl>    b5:fa:06:39:92:81:60:7a:1d
</span></span><span class=line><span class=cl>Exponent: 65537 (0x10001)
</span></span></code></pre></td></tr></table></div></div><p>RSA 描述的私钥的结构如下（其中除 $n, d$ 之外的都是冗余信息）：</p><ul><li><code>modulus</code>: 模数 $n$</li><li><code>publicExponent</code>: 公指数 $e$，固定为 65537 (0x10001)</li><li><code>privateExponent</code>: 私钥指数 $d$</li><li><code>prime1</code>: 质数 p，用于计算 $n$</li><li><code>prime2</code>: 质数 q，用于计算 $n$</li><li><code>exponent1</code>: 用于加速 RSA 运算的中国剩余定理指数一，$d \mod (p-1)$</li><li><code>exponent2</code>: 用于加速 RSA 运算的中国剩余定理指数二，$d \mod (q-1)$</li><li><code>coefficient</code>: 用于加速 RSA 运算的中国剩余定理系数，$q^{-1} \mod p$</li></ul><p>再看下 RSA 公钥的结构：</p><ul><li><code>modulus</code>: 模数 $n$</li><li><code>exponent</code>: 公指数 $e$，固定为 65537 (0x10001)</li></ul><p>可以看到私钥文件中就已经包含了公钥的所有参数，实际上我们也是使用 <code>openssl rsa -in rsa-private-key.pem -pubout -out rsa-public-key.pem</code> 命令通过私钥生成出的对应的公钥文件。</p><p>下面就介绍下具体的密钥对生成流程，搞清楚 openssl 生成出的这个私钥，各项参数分别是什么含义：</p><blockquote><p>这里不会详细介绍其中的各种数学证明，具体的请参考维基百科。
相关数学知识包括取模运算的性质、欧拉函数、模倒数（拓展欧几里得算法）</p></blockquote><ul><li>随机选择两个不相等的质数 $p$ 与 $q$<ul><li>p 跟 q 应该非常大，但是长度相差几个整数，这样会使得破解更加困难</li></ul></li><li>计算出模数 $n = pq$</li><li>计算欧拉函数的值 $\phi(n) = \phi(pq) = (p-1)(q-1)$</li><li>选择公指数 $e$，要求 $1 &lt; e &lt; \lambda (n)$，且 $e$ 与 $\phi(n)$ 互质，即 $\gcd(e, \phi(n)) = 1$。<ul><li>目前 openssl 固定使用 65537 (0x10001) 作为 e 的值</li><li>曾经也有使用过 3 作为 e 的值，但是目前 3 已被证明不够安全</li></ul></li><li>计算出使等式 $ed \equiv 1 \bmod \phi(n)$ 成立的值 $d$，它就是我们的私钥指数<ul><li>上述等式的含义：$ed$ 被 $\phi(n)$ 的余数为 $1$</li><li>等式可转换为 $ed = 1 + \phi(n) \cdot k$，其中 $k$ 为整数。</li><li>移项得 $e d + \phi(n) \cdot y = 1 = \gcd(e, \phi(n))$，其中 $y=-k$</li><li>上面的等式可使用<a href=https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95 target=_blank rel="noopener noreferrer">拓展欧几里得算法</a>求解，wiki 有给出此算法的 Python 实现，非常简洁。</li></ul></li><li>使用 $(n, e)$ 组成公钥，使用 $(n, d)$ 组成私钥。其他参数可以保存在私钥中，也可丢弃。<ul><li>$p, q, \phi(n), d$ 四个参数都必须保密，绝不能泄漏！</li></ul></li><li>在现有算力下，想要通过公钥的 $(n, e)$ 推算出 $d$ 是非常困难的，这保证了 RSA 算法的安全性。</li></ul><p>下面我们使用 Python 来通过 $p,q,e$ 计算出 $n, d$ 来，跟 openssl 打印的对比下，看看是否一致。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install cryptography==36.0.1</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>cryptography.hazmat.primitives</span> <span class=kn>import</span> <span class=n>serialization</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>key_path</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&#34;./rsa-private-key.pem&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>private_key</span> <span class=o>=</span> <span class=n>serialization</span><span class=o>.</span><span class=n>load_pem_private_key</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>key_path</span><span class=o>.</span><span class=n>read_bytes</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>password</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>private</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>private_numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>public</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>public_key</span><span class=p>()</span><span class=o>.</span><span class=n>public_numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>private</span><span class=o>.</span><span class=n>p</span>
</span></span><span class=line><span class=cl><span class=n>q</span> <span class=o>=</span> <span class=n>private</span><span class=o>.</span><span class=n>q</span>
</span></span><span class=line><span class=cl><span class=n>e</span> <span class=o>=</span> <span class=n>public</span><span class=o>.</span><span class=n>e</span>
</span></span><span class=line><span class=cl><span class=n>phi_n</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>q</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>extended_euclidean</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>      拓展欧几里得算法，能在计算出 a 与 b 的最大公约数的同时，给出 ax + by = gcd(a, b) 中的 x 与 y 的值
</span></span></span><span class=line><span class=cl><span class=s2>      代码来自 wiki: https://zh.wikipedia.org/wiki/</span><span class=si>%E</span><span class=s2>6</span><span class=si>%89%</span><span class=s2>A9</span><span class=si>%E</span><span class=s2>5%B1</span><span class=si>%95%</span><span class=s2>E6%AC%A7</span><span class=si>%E</span><span class=s2>5</span><span class=si>%87%</span><span class=s2>A0</span><span class=si>%E</span><span class=s2>9</span><span class=si>%87%</span><span class=s2>8C</span><span class=si>%E</span><span class=s2>5%BE</span><span class=si>%97%</span><span class=s2>E7%AE</span><span class=si>%97%</span><span class=s2>E6%B3%95
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>old_s</span><span class=p>,</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>old_t</span><span class=p>,</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>old_r</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>b</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>r</span><span class=o>!=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>q</span> <span class=o>=</span> <span class=n>old_r</span> <span class=o>//</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>            <span class=n>old_r</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>r</span><span class=p>,</span> <span class=n>old_r</span><span class=o>-</span><span class=n>q</span><span class=o>*</span><span class=n>r</span>
</span></span><span class=line><span class=cl>            <span class=n>old_s</span><span class=p>,</span> <span class=n>s</span> <span class=o>=</span> <span class=n>s</span><span class=p>,</span> <span class=n>old_s</span><span class=o>-</span><span class=n>q</span><span class=o>*</span><span class=n>s</span>
</span></span><span class=line><span class=cl>            <span class=n>old_t</span><span class=p>,</span> <span class=n>t</span> <span class=o>=</span> <span class=n>t</span><span class=p>,</span> <span class=n>old_t</span><span class=o>-</span><span class=n>q</span><span class=o>*</span><span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>old_s</span><span class=p>,</span> <span class=n>old_t</span><span class=p>,</span> <span class=n>old_r</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 我们只需要 d，y 可忽略，而余数 remainder 肯定为 1，也可忽略</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>remainder</span> <span class=o>=</span> <span class=n>extended_euclidean</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>phi_n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=n>p</span> <span class=o>*</span> <span class=n>q</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=nb>hex</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=si>=}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># =&gt; hex(n)=&#39;0xcd13c4192c965744439e599da2940cc60b82a3abf3dfb05ceb5c68fc83721a4b8fc9dc9ac1a37a84abf93d5e84733a634fcaf5828f614063b034f7d77ba97e33b6d841a5433678f0c8603be12f41297d0a9b85ef9069a81c169b8a4ec846476c018c7d02975fd6c4991f21432659853e9b888a2f0f4a7cb5fa06399281607a1d&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=nb>hex</span><span class=p>(</span><span class=n>d</span><span class=p>)</span><span class=si>=}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># =&gt; hex(d)=&#39;0xdbe4d5e0286f0c23a65da4b9e219dd987dbf16c0ca3e905d120184913e609ad16adc882f6872626cdff9e053f8b19569e7a5389b46228168630868b82561186f6ef89b528f0f1f8c28222753868d9eeacc05d9aa882e4e981490e9c5714215d6d73380a6d8ca9b0f856d9a1098a9bbee8b2114722f3762b44fd2324636dd061&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>对比 RSA 的输出，可以发现去掉冒号后，<code>d</code> 跟 <code>n</code> 的值是完全相同的。</p><h3 id=rsa-加密与解密 class=headerLink><a href=#rsa-%e5%8a%a0%e5%af%86%e4%b8%8e%e8%a7%a3%e5%af%86 class=header-mark></a>RSA 加密与解密</h3><p>RSA 加密算法，一次只能加密一个小于 $n$ 的非负整数，假设明文为整数 $msg$，加密算法如下：</p><p>$$
\text{encryptedMsg} = msg^e \mod n
$$</p><p>通常的手段是，先使用 <a href=https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding target=_blank rel="noopener noreferrer">EAOP</a> 将被加密消息编码成一个个符合条件的整数，再使用上述公式一个个加密。</p><p>解密的方法，就是对被每一段加密的数据 $encryptedMsg$，进行如下运算：</p><p>$$
\text{decryptedMsg} = \text{encryptedMsg}^d \mod n
$$</p><h4 id=rsa-解密运算的证明 class=headerLink><a href=#rsa-%e8%a7%a3%e5%af%86%e8%bf%90%e7%ae%97%e7%9a%84%e8%af%81%e6%98%8e class=header-mark></a>RSA 解密运算的证明</h4><blockquote><p>这里的证明需要用到一些数论知识，觉得不容易理解的话，建议自行查找相关资料。</p></blockquote><p>证明流程如下：</p><p>$$
\begin{alignedat}{2}
\text{decryptedMsg} &= &\text{encryptedMsg}^d &\mod n \\
&= &{(msg^e \mod n)}^d &\mod n \\
&= &{msg^{ed}} &\mod n \\
&= &{msg^{ed}} &\mod {pq}
\end{alignedat}
$$</p><p>接下来将下面两个等式代入上述计算中：</p><ul><li>我们在前面的「密钥对生成」一节中有给出等式：$ed = 1 + (p-1)(q-1) \cdot k$</li><li>因为 $0 \le msg \lt n$ 以及 $n = pq$，有 $msg \mod pq = msg$</li></ul><p>这样就得到：</p><p>$$
\begin{alignedat}{2}
\text{decryptedMsg} &= &{msg^{ed}} &\mod {pq} \\
&= &{(msg \mod pq) \cdot (msg^{ed-1} \mod pq)} &\mod {pq} \\
&= &{msg \cdot (msg^{(p-1)(q-1) \cdot k} \mod pq)} &\mod {pq}
\end{alignedat}
$$</p><p>又有<a href=https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86 target=_blank rel="noopener noreferrer">费马小定理</a>指出，在 $a$ 为整数，$p$ 为质数的情况下，有同余等式</p><p>$$a^{p-1} \equiv 1 {\pmod p}$$</p><p>因为我们的模数 $n=pq$ 并不是质数，不能直接利用费马小定理给出的同余公式。
但是 $p$, $q$ 两数都为质数，我们可以分别计算方程 对 $p$ 以及 $q$ 取模的结果，然后再根据<a href=https://zhuanlan.zhihu.com/p/44591114 target=_blank rel="noopener noreferrer">中国剩余定理</a>得出通解，也就得到我们需要的结果。</p><p>对于模 $p$ 的情况，计算方法如下：</p><ul><li>当 $msg = 0 \mod p$ 时，${msg^{ed}} \mod p = 0 \equiv msg \pmod p$</li><li>当 $msg \ne 0 \mod p$ 时，利用费马小定理，有
$$
\begin{alignedat}{2}
msg^{ed} &= &{msg \cdot (msg^{(p-1)(q-1) \cdot k} \mod p)} &\pmod {p} \\
&= &msg \cdot (msg^{(p-1)} \mod p)^{(q-1) \cdot k} &\pmod p \\
&= &msg \cdot 1^{(q-1) \cdot k} &\pmod p \\
&\equiv &msg \pmod p
\end{alignedat}
$$</li></ul><p>同理，对模 $q$ 的情况，也能得到等式</p><p>$$msg^{ed} \equiv msg \pmod q$$</p><p>有了上面两个结果，根据中国剩余定理，就能得到</p><p>$$msg^{ed} \equiv msg \pmod {pq}$$</p><p>现在再接续前面的计算：</p><p>$$
\begin{alignedat}{2}
\text{decryptedMsg} &= &{msg^{ed}} &\pmod {pq} \\
&= &msg &\pmod {pq} \\
&= &msg
\end{alignedat}
$$</p><p>这样就证明了，解密操作得到的就是原始信息。</p><p>因为非对称加解密非常慢，对于较大的文件，通常会分成两步加密来提升性能：首先用使用对称加密算法来加密数据，再使用 RSA 等非对称加密算法加密上一步用到的「对称密钥」。</p><p>下面我们用 Python 来验证下 RSA 算法的加解密流程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install cryptography==36.0.1</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>cryptography.hazmat.primitives</span> <span class=kn>import</span> <span class=n>serialization</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 私钥</span>
</span></span><span class=line><span class=cl><span class=n>key_path</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&#34;./rsa-private-key.pem&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>private_key</span> <span class=o>=</span> <span class=n>serialization</span><span class=o>.</span><span class=n>load_pem_private_key</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>key_path</span><span class=o>.</span><span class=n>read_bytes</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>password</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>private</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>private_numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>public</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>public_key</span><span class=p>()</span><span class=o>.</span><span class=n>public_numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>private</span><span class=o>.</span><span class=n>d</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 公钥</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=n>public</span><span class=o>.</span><span class=n>n</span>
</span></span><span class=line><span class=cl><span class=n>e</span> <span class=o>=</span> <span class=n>public</span><span class=o>.</span><span class=n>e</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>int_to_bytes</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bytes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=o>.</span><span class=n>to_bytes</span><span class=p>((</span><span class=n>x</span><span class=o>.</span><span class=n>bit_length</span><span class=p>()</span> <span class=o>+</span> <span class=mi>7</span><span class=p>)</span> <span class=o>//</span> <span class=mi>8</span><span class=p>,</span> <span class=s1>&#39;big&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>int_from_bytes</span><span class=p>(</span><span class=n>xbytes</span><span class=p>:</span> <span class=nb>bytes</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>xbytes</span><span class=p>,</span> <span class=s1>&#39;big&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fast_power_modular</span><span class=p>(</span><span class=n>b</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>p</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>m</span><span class=p>:</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    快速模幂运算：b^p % m
</span></span></span><span class=line><span class=cl><span class=s2>    复杂度： O(log p)
</span></span></span><span class=line><span class=cl><span class=s2>    因为 RSA 的底数跟指数都非常大，如果先进行幂运算，最后再取模，计算结果会越来越大，导致速度非常非常慢
</span></span></span><span class=line><span class=cl><span class=s2>    根据模幂运算的性质  b^(ab) % m = (b^a % m)^b % m, 可以通过边进行幂运算边取模，极大地提升计算速度
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>p</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>p</span> <span class=o>&amp;</span> <span class=mh>0x1</span><span class=p>:</span> <span class=n>res</span> <span class=o>*=</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=n>b</span> <span class=o>**</span> <span class=mi>2</span> <span class=o>%</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span> <span class=o>%</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 明文</span>
</span></span><span class=line><span class=cl><span class=n>original_msg</span> <span class=o>=</span> <span class=sa>b</span><span class=s2>&#34;an example&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>original_msg</span><span class=si>=}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 加密</span>
</span></span><span class=line><span class=cl><span class=n>msg_int</span> <span class=o>=</span> <span class=n>int_from_bytes</span><span class=p>(</span><span class=n>original_msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>encrypt_int</span> <span class=o>=</span> <span class=n>msg_int</span> <span class=o>**</span> <span class=n>e</span> <span class=o>%</span> <span class=n>n</span>
</span></span><span class=line><span class=cl><span class=n>encrypt_msg</span> <span class=o>=</span> <span class=n>int_to_bytes</span><span class=p>(</span><span class=n>encrypt_int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>encrypt_msg</span><span class=si>=}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 解密</span>
</span></span><span class=line><span class=cl><span class=c1># decrypt_int = encrypt_int ** d % n # 因为 d 非常大，直接使用公式计算会非常非常慢，所以不能这么算</span>
</span></span><span class=line><span class=cl><span class=n>decrypt_int</span> <span class=o>=</span> <span class=n>fast_power_modular</span><span class=p>(</span><span class=n>encrypt_int</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>decrypt_msg</span> <span class=o>=</span> <span class=n>int_to_bytes</span><span class=p>(</span><span class=n>decrypt_int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>decrypt_msg</span><span class=si>=}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 应该与原信息完全一致</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=rsa-数字签名 class=headerLink><a href=#rsa-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d class=header-mark></a>RSA 数字签名</h3><p>前面证明了可以使用公钥加密，再使用私钥解密。</p><p>实际上从上面的证明也可以看出来，顺序是完全可逆的，先使用私钥加密，再使用公钥解密也完全是可行的。这种运算被我们用在数字签名算法中。</p><p>数字签名的方法为：</p><ul><li>首先计算原始数据的 Hash 值，比如 SHA256</li><li>使用私钥对计算出的 Hash 值进行加密，得到数字签名</li><li>其他人使用公开的公钥进行解密出 Hash 值，再对原始数据计算 Hash 值对比，如果一致，就说明数据未被篡改</li></ul><p>Python 演示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install cryptography==36.0.1</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>hashlib</span> <span class=kn>import</span> <span class=n>sha512</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>cryptography.hazmat.primitives</span> <span class=kn>import</span> <span class=n>serialization</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>key_path</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&#34;./rsa-private-key.pem&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>private_key</span> <span class=o>=</span> <span class=n>serialization</span><span class=o>.</span><span class=n>load_pem_private_key</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>key_path</span><span class=o>.</span><span class=n>read_bytes</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=n>password</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>private</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>private_numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>public</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>public_key</span><span class=p>()</span><span class=o>.</span><span class=n>public_numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>private</span><span class=o>.</span><span class=n>d</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=n>public</span><span class=o>.</span><span class=n>n</span>
</span></span><span class=line><span class=cl><span class=n>e</span> <span class=o>=</span> <span class=n>public</span><span class=o>.</span><span class=n>e</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># RSA sign the message</span>
</span></span><span class=line><span class=cl><span class=n>msg</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A message for signing&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>hash</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>sha512</span><span class=p>(</span><span class=n>msg</span><span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>(),</span> <span class=n>byteorder</span><span class=o>=</span><span class=s1>&#39;big&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>signature</span> <span class=o>=</span> <span class=nb>pow</span><span class=p>(</span><span class=nb>hash</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Signature:&#34;</span><span class=p>,</span> <span class=nb>hex</span><span class=p>(</span><span class=n>signature</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># RSA verify signature</span>
</span></span><span class=line><span class=cl><span class=n>msg</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;A message for signing&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>hash</span> <span class=o>=</span> <span class=nb>int</span><span class=o>.</span><span class=n>from_bytes</span><span class=p>(</span><span class=n>sha512</span><span class=p>(</span><span class=n>msg</span><span class=p>)</span><span class=o>.</span><span class=n>digest</span><span class=p>(),</span> <span class=n>byteorder</span><span class=o>=</span><span class=s1>&#39;big&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>hashFromSignature</span> <span class=o>=</span> <span class=nb>pow</span><span class=p>(</span><span class=n>signature</span><span class=p>,</span> <span class=n>e</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Signature valid:&#34;</span><span class=p>,</span> <span class=nb>hash</span> <span class=o>==</span> <span class=n>hashFromSignature</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=四ecc-密码系统 class=headerLink><a href=#%e5%9b%9becc-%e5%af%86%e7%a0%81%e7%b3%bb%e7%bb%9f class=header-mark></a>四、ECC 密码系统</h2><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc.webp></figure><p>ECC 椭圆曲线密码学，于 1985 年被首次提出，并于 2004 年开始被广泛应用。
ECC 被认为是 RSA 的继任者，新一代的非对称加密算法。</p><p>其最大的特点在于相同密码强度下，ECC 的密钥和签名的大小都要显著低于 RSA. 256bits 的 ECC 密钥，安全性与 3072bits 的 RSA 密钥安全性相当。</p><p>其次 ECC 的密钥对生成、密钥交换与签名算法的速度都要比 RSA 快。</p><h3 id=椭圆曲线的数学原理简介 class=headerLink><a href=#%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e7%9a%84%e6%95%b0%e5%ad%a6%e5%8e%9f%e7%90%86%e7%ae%80%e4%bb%8b class=header-mark></a>椭圆曲线的数学原理简介</h3><p>在数学中，椭圆曲线（Elliptic Curves）是一种平面曲线，由如下方程定义的点的集合组成（$A-J$ 均为常数）：</p><p>$$
Ax^3 + Bx^2y + Cxy^2 + Dy^3 + Ex^2 + Fxy + Gy^2 + Hx + Iy + J = 0
$$</p><p>而 ECC 只使用了其中很简单的一个子集（$a, b$ 均为常数）：</p><p>$$
y^2 = x^3 + ax + b
$$</p><p>比如著名的 NIST 曲线 secp256k1 就是基于如下椭圆曲线方程：</p><p>$$
y^2 = x^3 + 7
$$</p><p>椭圆曲线大概长这么个形状：</p><blockquote><p>椭圆曲线跟椭圆的关系，就犹如雷锋跟雷峰塔、Java 跟 JavaScript&mldr;</p></blockquote><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/elliptic-curve.webp></figure><p>你可以通过如下网站手动调整 $a$ 与 $b$ 的值，拖动曲线的交点查看图形的变化情况：
<a href="https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN" target=_blank rel="noopener noreferrer">https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN</a></p><h4 id=椭圆曲线上的运算 class=headerLink><a href=#%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e4%b8%8a%e7%9a%84%e8%bf%90%e7%ae%97 class=header-mark></a>椭圆曲线上的运算</h4><p>数学家在椭圆曲线上定义了一些运算规则，ECC 就依赖于这些规则，下面简单介绍下我们用得到的部分。</p><blockquote><p>椭圆曲线上的运算跟我们所熟知的实数域运算不太一样，它在现实生活中并无实际意义，但是它的一些性质使其很适合被应用在密码学中。</p></blockquote><h5 id=1-加法与负元 class=headerLink><a href=#1-%e5%8a%a0%e6%b3%95%e4%b8%8e%e8%b4%9f%e5%85%83 class=header-mark></a>1. 加法与负元</h5><p>对于曲线上的任意两点 $A$ 与 $B$，我们定义过 $A, B$ 的直线与曲线的交点为 $-(A+B)$，而 $-(A+B)$ 相对于 x 轴的对称点即为 $A+B$:</p><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc-add-operation.webp></figure><p>上述描述一是定义了椭圆曲线的加法规则，二是定义了椭圆曲线上的负元运算。</p><h5 id=2-二倍运算 class=headerLink><a href=#2-%e4%ba%8c%e5%80%8d%e8%bf%90%e7%ae%97 class=header-mark></a>2. 二倍运算</h5><p>在加法规则中，如果 $A=B$，我们定义曲线在 $A$ 点的切线与曲线的交点为 $-2A$，于是得到二倍运算的规则：</p><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc-2-times.webp></figure><h5 id=3-无穷远点 class=headerLink><a href=#3-%e6%97%a0%e7%a9%b7%e8%bf%9c%e7%82%b9 class=header-mark></a>3. 无穷远点</h5><p>对于 $(-A) + A$ 这种一个值与其负元本身相加的情况，我们会发现过这两点的直线与椭圆曲线没有第三个交点，前面定义的加法规则在这种情况下失效了。
为了解决这个问题，我们假设这条直线与椭圆曲线相交于无穷远点 $O_{\infty}$.</p><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc-ifinite-point.webp></figure><h5 id=4-k-倍运算 class=headerLink><a href=#4-k-%e5%80%8d%e8%bf%90%e7%ae%97 class=header-mark></a>4. k 倍运算</h5><p>我们在前面已经定义了椭圆曲线上的<strong>加法运算</strong>、<strong>二倍运算</strong>以及<strong>无穷远点</strong>，有了这三个概念，我们就能定义<strong>k 倍运算</strong> 了。</p><p>K 倍运算最简单的计算方法，就是不断地进行加法运算，但是也有许多更高效的算法。
其中最简单的算法是「double-and-add」，它要求首先 $k$ 拆分成如下形式</p><p>$$
k = k_{0}+2k_{1}+2^{2}k_{2}+\cdots +2^{m}k_{m} \\
\text{其中} k_{0}~..~k_{m}\in {0,1},m=\lfloor \log _{2}{k}\rfloor
$$</p><p>然后再迭代计算其中各项的值，它的运算复杂度为 $log_{2}(k)$.</p><p>因 Double 和 Add 的执行时间不同，根据执行时间就可以知道是执行 Double 还是 Add，间接可以推算出 $k$. 因此这个算法会有计时攻击的风险。
基于「double-and-add」修改的蒙哥马利阶梯（Montgomery Ladder）是可以避免计时分析的作法，这里就不详细介绍了。</p><h4 id=5-有限域上的椭圆曲线 class=headerLink><a href=#5-%e6%9c%89%e9%99%90%e5%9f%9f%e4%b8%8a%e7%9a%84%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf class=header-mark></a>5. 有限域上的椭圆曲线</h4><p>椭圆曲线是连续且无限的，而计算机却更擅长处理离散的、存在上限的整数，因此 ECC 使用「有限域上的椭圆曲线」进行计算。</p><p>「有限域（也被称作 Galois Filed, 缩写为 GF）」顾名思义，就是指只有有限个数值的域。</p><p>有限域上的椭圆曲线方程，通过取模的方式将曲线上的所有值都映射到同一个有限域内。
有限域 $\mathbb {F} _{p}$ 上的 EC 椭圆曲线方程为：</p><p>$$
y^2 = x^3 + ax + b (\mod p), 0 \le x \le p
$$</p><p>目前主要有两种有限域在 ECC 中被广泛应用：</p><ul><li>以素数为模的整数域: $\mathbb {F} _{p}$<ul><li>在通用处理器上计算很快</li></ul></li><li>以 2 的幂为模的整数域: $\mathbb {F} _{2^{m}}$<ul><li>当使用专用硬件时，计算速度很快</li></ul></li></ul><p>通过限制 x 为整数，并使用取模进行了映射后，椭圆曲线的形状已经面目全非了，它的加减法也不再具有几何意义。
但是它的一些特性仍然跟椭圆曲线很类似，各种公式基本加个 $\mod p$ 就变成了它的有限域版本：</p><ul><li>无穷远点 $O_{\infty}$ 是零元，$O_{\infty} + O_{\infty} = O_{\infty}$，$O_{\infty} + P = P$</li><li>$P_{x, y}$ 的负元为 $P_{x, -y}$,，并且有 $P + (-P) = O_{\infty}$</li><li>$P * 0 = O_{\infty}$</li><li>如果 $P_{x1, y1} + Q_{x2, y2} = R_{x3, y3}$，则其坐标有如下关系<ul><li>$x3 = (k^2 - x1 - x2) \mod p$</li><li>$y3 = (k(x1 - x3) - y1) \mod p$</li><li>斜率 $k$ 的计算<ul><li>如果 $P=Q$，则 $k=\dfrac {3x^{2}+a} {2y_{1}}$</li><li>否则 $k=\dfrac {y_{2}-y_{1}} {x_{2}-x_{1}} $</li></ul></li></ul></li></ul><h4 id=ecdlp-椭圆曲线离散对数问题 class=headerLink><a href=#ecdlp-%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e7%a6%bb%e6%95%a3%e5%af%b9%e6%95%b0%e9%97%ae%e9%a2%98 class=header-mark></a>ECDLP 椭圆曲线离散对数问题</h4><p>前面已经介绍了椭圆曲线上的 <strong>k 倍运算</strong> 及相关的高效算法，但是我们还没有涉及到除法。</p><p>椭圆曲线上的除法是一个尚未被解决的难题——「ECDLP 椭圆曲线离散对数问题」：</p><blockquote><p>已知 $kG$ 与基点 $G$，求整数 $k$ 的值。</p></blockquote><p>目前并没有有效的手段可以快速计算出 $k$ 的值。
比较直观的方法应该是从基点 $G$ 开始不断进行加法运算，直到结果与 $kG$ 相等。</p><p>目前已知的 ECDLP 最快的解法所需步骤为 $\sqrt{k}$，而 <strong>k 倍运算</strong>高效算法前面已经介绍过了，所需步骤为 $log_2(k)$。
在 $k$ 非常大的情况下，它们的计算用时将会有指数级的差距。</p><blockquote><p>椭圆曲线上的 <strong>k 倍运算</strong>与素数上的幂运算很类似，因此 ECC 底层的数学难题 ECDLP 与 RSA 的离散对数问题 DLP 也有很大相似性。</p></blockquote><h3 id=ecc-密钥对生成 class=headerLink><a href=#ecc-%e5%af%86%e9%92%a5%e5%af%b9%e7%94%9f%e6%88%90 class=header-mark></a>ECC 密钥对生成</h3><p>首先，跟 RSA 一样，让我们先看下怎么使用 openssl 生成一个使用 prime256v1 曲线的 ECC 密钥对：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 列出 openssl 支持的所有曲线名称</span>
</span></span><span class=line><span class=cl>openssl ecparam -list_curves
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 生成 ec 算法的私钥，使用 prime256v1 算法，密钥长度 256 位。（强度大于 2048 位的 RSA 密钥）</span>
</span></span><span class=line><span class=cl>openssl ecparam -genkey -name prime256v1 -out ecc-private-key.pem
</span></span><span class=line><span class=cl><span class=c1># 通过密钥生成公钥</span>
</span></span><span class=line><span class=cl>openssl ec -in ecc-private-key.pem -pubout -out ecc-public-key.pem
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看私钥内容</span>
</span></span><span class=line><span class=cl>❯ cat ecc-private-key.pem
</span></span><span class=line><span class=cl>-----BEGIN EC PARAMETERS-----
</span></span><span class=line><span class=cl><span class=nv>BggqhkjOPQMBBw</span><span class=o>==</span>
</span></span><span class=line><span class=cl>-----END EC PARAMETERS-----
</span></span><span class=line><span class=cl>-----BEGIN EC PRIVATE KEY-----
</span></span><span class=line><span class=cl>MHcCAQEEIGm3wT/m4gDaoJGKfAHDXV2BVtdyb/aPTITJR5B6KVEtoAoGCCqGSM49
</span></span><span class=line><span class=cl>AwEHoUQDQgAE5IEIorw0WU5+om/UgfyYSKosiGO6Hpe8hxkqL5GUVPyu4LJkfw/e
</span></span><span class=line><span class=cl>99zhNJatliZ1Az/yCKww5KrXC8bQ9wGQvw<span class=o>==</span>
</span></span><span class=line><span class=cl>-----END EC PRIVATE KEY-----
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看私钥的详细参数</span>
</span></span><span class=line><span class=cl>❯ openssl ec -noout -text -in ecc-private-key.pem
</span></span><span class=line><span class=cl><span class=nb>read</span> EC key
</span></span><span class=line><span class=cl>Private-Key: <span class=o>(</span><span class=m>256</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>priv:
</span></span><span class=line><span class=cl>    69:b7:c1:3f:e6:e2:00:da:a0:91:8a:7c:01:c3:5d:
</span></span><span class=line><span class=cl>    5d:81:56:d7:72:6f:f6:8f:4c:84:c9:47:90:7a:29:
</span></span><span class=line><span class=cl>    51:2d
</span></span><span class=line><span class=cl>pub: 
</span></span><span class=line><span class=cl>    04:e4:81:08:a2:bc:34:59:4e:7e:a2:6f:d4:81:fc:
</span></span><span class=line><span class=cl>    98:48:aa:2c:88:63:ba:1e:97:bc:87:19:2a:2f:91:
</span></span><span class=line><span class=cl>    94:54:fc:ae:e0:b2:64:7f:0f🇩🇪f7:dc:e1:34:96:
</span></span><span class=line><span class=cl>    ad:96:26:75:03:3f:f2:08:ac:30:e4:aa:d7:0b:c6:
</span></span><span class=line><span class=cl>    d0:f7:01:90:bf
</span></span><span class=line><span class=cl>ASN1 OID: prime256v1
</span></span><span class=line><span class=cl>NIST CURVE: P-256
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看公钥内容</span>
</span></span><span class=line><span class=cl>❯ cat ecc-public-key.pem 
</span></span><span class=line><span class=cl>-----BEGIN PUBLIC KEY-----
</span></span><span class=line><span class=cl>MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5IEIorw0WU5+om/UgfyYSKosiGO6
</span></span><span class=line><span class=cl>Hpe8hxkqL5GUVPyu4LJkfw/e99zhNJatliZ1Az/yCKww5KrXC8bQ9wGQvw<span class=o>==</span>
</span></span><span class=line><span class=cl>-----END PUBLIC KEY-----
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看公钥的参数</span>
</span></span><span class=line><span class=cl>❯ openssl ec -noout -text -pubin -in ecc-public-key.pem
</span></span><span class=line><span class=cl><span class=nb>read</span> EC key
</span></span><span class=line><span class=cl>Private-Key: <span class=o>(</span><span class=m>256</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>pub: 
</span></span><span class=line><span class=cl>    04:e4:81:08:a2:bc:34:59:4e:7e:a2:6f:d4:81:fc:
</span></span><span class=line><span class=cl>    98:48:aa:2c:88:63:ba:1e:97:bc:87:19:2a:2f:91:
</span></span><span class=line><span class=cl>    94:54:fc:ae:e0:b2:64:7f:0f🇩🇪f7:dc:e1:34:96:
</span></span><span class=line><span class=cl>    ad:96:26:75:03:3f:f2:08:ac:30:e4:aa:d7:0b:c6:
</span></span><span class=line><span class=cl>    d0:f7:01:90:bf
</span></span><span class=line><span class=cl>ASN1 OID: prime256v1
</span></span><span class=line><span class=cl>NIST CURVE: P-256
</span></span></code></pre></td></tr></table></div></div><p>可以看到 ECC 算法的公钥私钥都比 RSA 小了非常多，数据量小，却能带来同等的安全强度，这是 ECC 相比 RSA 最大的优势。</p><p>私钥的参数：</p><ul><li><code>priv</code>: 私钥，一个 256bits 的大整数，对应我们前面介绍的 $k 倍运算$中的 $k$</li><li><code>pub</code>: 公钥，是一个椭圆曲线（EC）上的坐标 ${x, y}$，也就是我们 well-known 的基点 $G$</li><li><code>ASN1 OID</code>: prime256v1, 椭圆曲线的名称</li><li><code>NIST CURVE</code>: P-256</li></ul><p>使用安全随机数生成器即可直接生成出 ECC 的私钥 <code>priv</code>，因此 ECC 的密钥对生成速度非常快。</p><h3 id=ecdh-密钥交换 class=headerLink><a href=#ecdh-%e5%af%86%e9%92%a5%e4%ba%a4%e6%8d%a2 class=header-mark></a>ECDH 密钥交换</h3><p>这个在前面<a href=/posts/practical-cryptography-basics-5-key-exchange/ rel>写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a>已经介绍过了，不过这里再复述一遍：</p><ul><li>Alice 跟 Bob 协商好椭圆曲线的各项参数，以及基点 G，这些参数都是公开的。</li><li>Alice 生成一个随机的 ECC 密钥对（公钥：$alicePrivate * G$, 私钥: $alicePrivate$）</li><li>Bob 生成一个随机的 ECC 密钥对（公钥：$bobPrivate * G$, 私钥: $bobPrivate$）</li><li>两人通过不安全的信道交换公钥</li><li>Alice 将 Bob 的公钥乘上自己的私钥，得到共享密钥 $sharedKey = (bobPrivate * G) * alicePrivate$</li><li>Bob 将 Alice 的公钥乘上自己的私钥，得到共享密钥 $sharedKey = (alicePrivate * G) * bobPrivate$</li><li>因为 $(a * G) * b = (b * G) * a$，Alice 与 Bob 计算出的共享密钥应该是相等的</li></ul><p>这样两方就通过 ECDH 完成了密钥交换。
而 ECDH 的安全性，则由 ECDLP 问题提供保证。</p><h3 id=ecc-加密与解密 class=headerLink><a href=#ecc-%e5%8a%a0%e5%af%86%e4%b8%8e%e8%a7%a3%e5%af%86 class=header-mark></a>ECC 加密与解密</h3><p>ECC 本身并没有提供加密与解密的功能，但是我们可以借助 ECDH 迂回实现加解密。流程如下：</p><ol><li>Bob 想要将消息 <code>M</code> 安全地发送给 Alice，他手上已经拥有了 Alice 的 ECC 公钥 <code>alicePubKey</code></li><li>Bob 首先使用如下算法生成出「共享密钥」+「密文公钥」<ol><li>随机生成一个临时用的密文 ECC 密钥对<ul><li>密文私钥 <code>ciphertextPrivKey</code>：生成一个安全随机数作为私钥即可</li><li>密文公钥 <code>ciphertextPubKey</code>：使用此公式从私钥生成 <code>ciphertextPubKey =ciphertextPrivKey * G</code></li></ul></li><li>使用 ECDH 算法计算出「共享密钥」：<code>sharedECCKey = alicePubKey * ciphertextPrivKey</code></li><li>为了确保安全性，每份密文都应该使用不同的「<strong>临时 ECC 密钥对</strong>」作为「密文密钥对」，不应该直接使用「Bob 的密钥对」！「Bob 的密钥对」只在 Alice 回复密文消息给 Bob 时才应该被用到。</li></ol></li><li>Bob 使用「共享密钥」与对称加密算法加密消息，得到密文 <code>C</code><ul><li>比如使用 AES-256-GCM 或者 ChaCha20-Poly1305 进行对称加密</li></ul></li><li>Bob 将 <code>C</code> 与「密文公钥 <code>ciphertextPubKey</code>」打包传输给 Alice</li><li>Alice 使用「密文公钥」与自己的私钥计算出「共享密钥」<code>sharedECCKey = ciphertextPubKey * alicePrivKey</code><ol><li>根据 ECDH 算法可知，这里计算出的共享密钥 <code>sharedECCKey</code>，跟 Bob 加密数据使用的共享密钥是完全一致的</li></ol></li><li>Alice 使用计算出的共享密钥解密 <code>C</code> 得到消息 <code>M</code></li></ol><p>实际上就是消息的发送方先生成一个临时的 ECC 密钥对，然后借助 ECDH 协议计算出共享密钥用于加密。
消息的接收方同样通过 ECDH 协议计算出共享密钥再解密数据。</p><p>使用 Python 演示如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install tinyec  # &lt;= ECC 曲线库</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>tinyec</span> <span class=kn>import</span> <span class=n>registry</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>secrets</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用这条曲线进行演示</span>
</span></span><span class=line><span class=cl><span class=n>curve</span> <span class=o>=</span> <span class=n>registry</span><span class=o>.</span><span class=n>get_curve</span><span class=p>(</span><span class=s1>&#39;brainpoolP256r1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>compress_point</span><span class=p>(</span><span class=n>point</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>hex</span><span class=p>(</span><span class=n>point</span><span class=o>.</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=nb>hex</span><span class=p>(</span><span class=n>point</span><span class=o>.</span><span class=n>y</span> <span class=o>%</span> <span class=mi>2</span><span class=p>)[</span><span class=mi>2</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ecc_calc_encryption_keys</span><span class=p>(</span><span class=n>pubKey</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    安全地生成一个随机 ECC 密钥对，然后按 ECDH 流程计算出共享密钥 sharedECCKey
</span></span></span><span class=line><span class=cl><span class=s2>    最后返回（共享密钥, 临时 ECC 公钥 ciphertextPubKey）
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>ciphertextPrivKey</span> <span class=o>=</span> <span class=n>secrets</span><span class=o>.</span><span class=n>randbelow</span><span class=p>(</span><span class=n>curve</span><span class=o>.</span><span class=n>field</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>ciphertextPubKey</span> <span class=o>=</span> <span class=n>ciphertextPrivKey</span> <span class=o>*</span> <span class=n>curve</span><span class=o>.</span><span class=n>g</span>
</span></span><span class=line><span class=cl>    <span class=n>sharedECCKey</span> <span class=o>=</span> <span class=n>pubKey</span> <span class=o>*</span> <span class=n>ciphertextPrivKey</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>sharedECCKey</span><span class=p>,</span> <span class=n>ciphertextPubKey</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ecc_calc_decryption_key</span><span class=p>(</span><span class=n>privKey</span><span class=p>,</span> <span class=n>ciphertextPubKey</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>sharedECCKey</span> <span class=o>=</span> <span class=n>ciphertextPubKey</span> <span class=o>*</span> <span class=n>privKey</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sharedECCKey</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. 首先生成出 Alice 的 ECC 密钥对</span>
</span></span><span class=line><span class=cl><span class=n>privKey</span> <span class=o>=</span> <span class=n>secrets</span><span class=o>.</span><span class=n>randbelow</span><span class=p>(</span><span class=n>curve</span><span class=o>.</span><span class=n>field</span><span class=o>.</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pubKey</span> <span class=o>=</span> <span class=n>privKey</span> <span class=o>*</span> <span class=n>curve</span><span class=o>.</span><span class=n>g</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;private key:&#34;</span><span class=p>,</span> <span class=nb>hex</span><span class=p>(</span><span class=n>privKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;public key:&#34;</span><span class=p>,</span> <span class=n>compress_point</span><span class=p>(</span><span class=n>pubKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. Alice 将公钥发送给 Bob</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. Bob 使用 Alice 的公钥生成出（共享密钥, 临时 ECC 公钥 ciphertextPubKey）</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>encryptKey</span><span class=p>,</span> <span class=n>ciphertextPubKey</span><span class=p>)</span> <span class=o>=</span> <span class=n>ecc_calc_encryption_keys</span><span class=p>(</span><span class=n>pubKey</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;ciphertext pubKey:&#34;</span><span class=p>,</span> <span class=n>compress_point</span><span class=p>(</span><span class=n>ciphertextPubKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;encryption key:&#34;</span><span class=p>,</span> <span class=n>compress_point</span><span class=p>(</span><span class=n>encryptKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. Bob 使用共享密钥 encryptKey 加密数据，然后将密文与 ciphertextPubKey 一起发送给 Alice</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 5. Alice 使用自己的私钥 + ciphertextPubKey 计算出共享密钥 decryptKey</span>
</span></span><span class=line><span class=cl><span class=n>decryptKey</span> <span class=o>=</span> <span class=n>ecc_calc_decryption_key</span><span class=p>(</span><span class=n>privKey</span><span class=p>,</span> <span class=n>ciphertextPubKey</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;decryption key:&#34;</span><span class=p>,</span> <span class=n>compress_point</span><span class=p>(</span><span class=n>decryptKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 6. Alice 使用 decryptKey 解密密文得到原始消息</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=ecc-数字签名 class=headerLink><a href=#ecc-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d class=header-mark></a>ECC 数字签名</h3><p>前面已经介绍了 RSA 签名，这里介绍下基于 ECC 的签名算法。</p><p>基于 ECC 的签名算法主要有两种：ECDSA 与 EdDSA，以及 EdDSA 的变体。
其中 ECDSA 算法稍微有点复杂，而安全强度跟它基本一致的 EdDSA 的算法更简洁更易于理解，在使用特定曲线的情况下 EdDSA 还要比 ECDSA 更快一点，因此现在通常更推荐使用 <strong>EdDSA</strong> 算法。</p><h4 id=eddsa-与-ed25519-签名算法 class=headerLink><a href=#eddsa-%e4%b8%8e-ed25519-%e7%ad%be%e5%90%8d%e7%ae%97%e6%b3%95 class=header-mark></a>EdDSA 与 Ed25519 签名算法</h4><p>EdDSA（Edwards-curve Digital Signature Algorithm）是一种现代的安全数字签名算法，它使用专为性能优化的椭圆曲线，如 255bits 曲线 edwards25519 和 448bits 曲线 edwards448.</p><p>EdDSA 签名算法及其变体 Ed25519 和 Ed448 在技术上在 <a href=https://tools.ietf.org/html/rfc8032 target=_blank rel="noopener noreferrer">RFC8032</a> 中进行了描述。</p><p>首先，用户需要基于 edwards25519 或者 edwards448 曲线，生成一个 ECC 密钥对。
生成私钥的时候，算法首先生成一个随机数，然后会对随机数做一些变换以确保安全性，防范计时攻击等攻击手段。
对于 edwards25519 公私钥都是 32 字节，而对于 edwards448 公私钥都是 57 字节。</p><p>对于 edwards25519 输出的签名长度为 64 字节，而对于 Ed448 输出为 114 字节。</p><p>具体的算法虽然比 ECDSA 简单，但还是有点难度的，这里就直接略过了。</p><p>下面给出个 ed25519 的计算示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install cryptography==36.0.1</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>cryptography.hazmat.primitives.asymmetric.ed25519</span> <span class=kn>import</span> <span class=n>Ed25519PrivateKey</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 也可用 openssl 生成，都没啥毛病</span>
</span></span><span class=line><span class=cl><span class=n>private_key</span> <span class=o>=</span> <span class=n>Ed25519PrivateKey</span><span class=o>.</span><span class=n>generate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 签名</span>
</span></span><span class=line><span class=cl><span class=n>signature</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;my authenticated message&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显然 ECC 的公钥 kG 也能直接从私钥 k 生成</span>
</span></span><span class=line><span class=cl><span class=n>public_key</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>public_key</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 验证</span>
</span></span><span class=line><span class=cl><span class=c1># Raises InvalidSignature if verification fails</span>
</span></span><span class=line><span class=cl><span class=n>public_key</span><span class=o>.</span><span class=n>verify</span><span class=p>(</span><span class=n>signature</span><span class=p>,</span> <span class=sa>b</span><span class=s2>&#34;my authenticated message&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>ed448 的代码也完全类似：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install cryptography==36.0.1</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>cryptography.hazmat.primitives.asymmetric.ed448</span> <span class=kn>import</span> <span class=n>Ed448PrivateKey</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>private_key</span> <span class=o>=</span> <span class=n>Ed448PrivateKey</span><span class=o>.</span><span class=n>generate</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>signature</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>sign</span><span class=p>(</span><span class=sa>b</span><span class=s2>&#34;my authenticated message&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>public_key</span> <span class=o>=</span> <span class=n>private_key</span><span class=o>.</span><span class=n>public_key</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># Raises InvalidSignature if verification fails</span>
</span></span><span class=line><span class=cl><span class=n>public_key</span><span class=o>.</span><span class=n>verify</span><span class=p>(</span><span class=n>signature</span><span class=p>,</span> <span class=sa>b</span><span class=s2>&#34;my authenticated message&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=密码学常用椭圆曲线介绍 class=headerLink><a href=#%e5%af%86%e7%a0%81%e5%ad%a6%e5%b8%b8%e7%94%a8%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e4%bb%8b%e7%bb%8d class=header-mark></a>密码学常用椭圆曲线介绍</h3><p>在介绍密码学中的常用椭圆曲线前，需要先介绍一下椭圆曲线的<strong>阶</strong>（order）以及<strong>辅助因子</strong>（cofactor）这两个概念。</p><p>首先还得介绍下数学中「循环群」的概念，它是指能由单个元素所生成的群，在 ECC 中这就是预先定义好的基点 $G$.</p><p>一个有限域上的椭圆曲线可以形成一个有限「循环代数群」，它由曲线上的所有点组成。椭圆曲线的<strong>阶</strong>被定义为该曲线上所有点的个数（包括无穷远点）。</p><p>有些曲线加上 G 点可以形成一个单一循环群，这一个群包含了曲线上的所有点。而其他的曲线加上 G 点则形成多个不相交的循环子群，每个子群包含了曲线的一个子集。
对于上述第二种情况，假设曲线上的点被拆分到了 <strong>h</strong> 个循环子群中，每个子群的<strong>阶</strong>都是 <strong>r</strong>，那这时整个群的阶就是 $n = h * r$，其中子群的个数 <strong>h</strong> 被称为<strong>辅助因子</strong>。</p><figure><img src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/elliptic-curve-subgroups.webp></figure><p>有限域上的椭圆曲线的阶都是有限的，也就是说对于曲线上任意一点 $G$，我们计算它的数乘 $kG$，随着整数 $k$ 的增大，一定会存在某个 $k$ 使 $kG = O_{\infty}$ 成立，然后 $k$ 继续增大时，因为 $O_{\infty} * P = O_{\infty}$，$kG$ 的值就固定为 $O_{\infty}$ 了，更大的 $k$ 值已经失去了意义。</p><p>因此 ECC 中要求 $kG$ 中的私钥 $k$ 符合条件 $0 \le k \le r$，也就是说总的私钥数量是受 $r$ 限制的。</p><p>辅助因子通过用如下公式表示：</p><p>$$
h = n / r
$$</p><p>其中 $n$ 是曲线的阶，$r$ 是每个子群的阶，$h$ 是辅助因子。
如果曲线形成了一个单一循环群，那显然 $h = 1$，否则 $h > 1$</p><p>举例如下：</p><ul><li><code>secp256k1</code> 的辅助因子为 1</li><li><code>Curve25519</code> 的辅助因子为 8</li><li><code>Curve448</code> 的辅助因子为 4</li></ul><h4 id=生成点-g class=headerLink><a href=#%e7%94%9f%e6%88%90%e7%82%b9-g class=header-mark></a>生成点 G</h4><p>生成点 G 的选择是很有讲究的，虽然每个循环子群都包含有很多个生成点，但是 ECC 只会谨慎的选择其中一个。
首先 G 点必须要能生成出整个循环子群，其次还需要有尽可能高的计算性能。</p><p>数学上已知某些椭圆曲线上，不同的生成点生成出的循环子群，阶也是不同的。如果 G 点选得不好，可能会导致生成出的子群的阶较小。
前面我们已经提过子群的阶 $r$ 会限制总的私钥数量，导致算法强度变弱！因此不恰当的 $G$ 点可能会导致我们遭受「<a href=https://datatracker.ietf.org/doc/html/rfc2785 target=_blank rel="noopener noreferrer">小子群攻击</a>」。
为了避免这种风险，建议尽量使用被广泛使用的加密库，而不是自己撸一个。</p><h4 id=椭圆曲线的域参数 class=headerLink><a href=#%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e7%9a%84%e5%9f%9f%e5%8f%82%e6%95%b0 class=header-mark></a>椭圆曲线的域参数</h4><p>ECC椭圆曲线由一组椭圆曲线域参数描述，如曲线方程参数、场参数和生成点坐标。这些参数在各种密码学标准中指定，你可以网上搜到相应的 RFC 或 NIST 文档。</p><p>这些标准定义了一组命名曲线的参数，例如 secp256k1、P-521、brainpoolP512t1 和 SM2. 这些加密标准中描述的有限域上的椭圆曲线得到了密码学家的充分研究和分析，并被认为具有一定的安全强度。</p><p>也有一些密码学家（如 Daniel Bernstein）认为，官方密码标准中描述的大多数曲线都是「不安全的」，并定义了他们自己的密码标准，这些标准在更广泛的层面上考虑了 ECC 安全性。</p><p>开发人员应该仅使用各项标准文档给出的、经过密码学家充分研究的命名曲线。</p><h5 id=secp256k1 class=headerLink><a href=#secp256k1 class=header-mark></a>secp256k1</h5><p>此曲线被应用在比特币中，它的域参数如下：</p><ul><li><em><strong>p</strong></em> (modulus) = <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</code></li><li><em><strong>n</strong></em> (order; size; the count of all possible EC points) = <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</code></li><li><em><strong>a</strong></em> (方程 $y^2 ≡ x^3 + a*x + b (\mod p)$ 中的常数) = <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li><li><em><strong>b</strong></em> (方程 $y^2 ≡ x^3 + a*x + b (\mod p)$ 中的常数)= <code>0x0000000000000000000000000000000000000000000000000000000000000007</code></li><li><em><strong>g</strong></em> (the curve generator point G {x, y}) = (<code>0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</code>, <code>0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</code>)</li><li><em><strong>h</strong></em> (cofactor, typically 1) = 01</li></ul><h5 id=edwards-曲线 class=headerLink><a href=#edwards-%e6%9b%b2%e7%ba%bf class=header-mark></a>Edwards 曲线</h5><p>椭圆曲线方程除了我们前面使用的 Weierstrass 形式 $$y^2 = (x^3 + ax + b) \mod p$$ 外，还可以被写成其他多种形式，这些不同的形式是<a href=https://zh.wikipedia.org/zh-hans/%E6%9C%89%E7%90%86%E6%98%A0%E5%B0%84 target=_blank rel="noopener noreferrer">双有理等价</a>的（别问，我也不懂什么叫「双有理等价」&mldr;）。
不同的方程形式在计算机的数值计算上可能会存在区别。</p><p>为了性能考虑，ECC 在部分场景下会考虑使用 Edwards 曲线形式进行计算，该方程形式如下：</p><p>$$
x^{2}+y^{2}=1+dx^{2}y^{2}
$$</p><p>画个图长这样：</p><p><a class=lightgallery href=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp title=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp data-thumbnail=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp><img class=lazyload data-src=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp data-srcset="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp, /images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp 1.5x, /images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp 2x" data-sizes=auto alt=/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp></a></p><p>知名的 Edwards 曲线有：</p><ul><li>Curve1174 (251-bit)</li><li>Curve25519 (255-bit)</li><li>Curve383187 (383-bit)</li><li>Curve41417 (414-bit)</li><li>Curve448 (448-bit)</li><li>E-521 (521-bit)</li><li>&mldr;</li></ul><h5 id=curve25519-x25519-和-ed25519 class=headerLink><a href=#curve25519-x25519-%e5%92%8c-ed25519 class=header-mark></a>Curve25519, X25519 和 Ed25519</h5><blockquote><p><a href=https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed25519/ target=_blank rel="noopener noreferrer">https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed25519/</a></p></blockquote><p>只要域参数选得好，Edwards 就可以以非常高的性能实现 ECC 密钥交换、数字签名、混合加密方案。</p><p>一个例子就是 <a href=https://en.wikipedia.org/wiki/Curve25519 target=_blank rel="noopener noreferrer">Curve25519</a>，它是 Edwards 曲线，其 Montgomery 形式的定义如下：</p><p>$$
y^{2}=x^{3}+486662x^{2}+x
$$</p><p>其被定义在有限域 $\mathbb {F} _{p}$ 上，$p = 2255 - 19$, 其他域参数如下：</p><ul><li>阶 <code>n = 2252 + 0x14def9dea2f79cd65812631a5cf5d3ed</code></li><li>辅因子 <code>h = 8</code></li></ul><p>虽然此曲线并未以 Edwards 形式定义，但是它已被证明与如下扭曲 Edwards 曲线（<code>edwards25519</code>）双有理等价：</p><p>$$
-x^2 + y^2 = 1 + 37095705934669439343138083508754565189542113879843219016388785533085940283555 x^2 y^2
$$</p><p>上面给出的这种 Edwards 形式与前文给出的 Weierstrass 形式完全等价，是专为计算速度优化而设计成这样的。</p><p>Curve25519 由 Daniel Bernstein 领导的密码学家团队精心设计，在多个设计和实现层面上达成了非常高的性能，同时不影响安全性。</p><p>Curve25519 的构造使其避免了许多潜在的实现缺陷。根据设计，它不受定时攻击的影响，并且它接受任何 32 字节的字符串作为有效的公钥，并且不需要验证。
它能提供 125.8bits 的安全强度（有时称为 ~ 128bits 安全性）</p><p>Curve25519 的私钥为 251 位，通常编码为 256 位整数（32 个字节，64 个十六进制数字）。
公钥通常也编码为 256 位整数（255 位 y 坐标 + 1 位 x 坐标），这对开发人员来说非常方便。</p><p>基于 Curve25519 派生出了名为 <a href=https://en.wikipedia.org/wiki/Curve25519 target=_blank rel="noopener noreferrer">X25519</a> 的 ECDH 算法，以及基于 EdDSA 的高速数字签名算法 <a href=https://en.wikipedia.org/wiki/EdDSA#Ed25519 target=_blank rel="noopener noreferrer">Ed25519</a>.</p><h5 id=curve448-x448-和-ed448 class=headerLink><a href=#curve448-x448-%e5%92%8c-ed448 class=header-mark></a>Curve448, X448 和 Ed448</h5><blockquote><p><a href=https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed448/ target=_blank rel="noopener noreferrer">https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed448/</a></p></blockquote><p><a href=https://en.wikipedia.org/wiki/Curve448 target=_blank rel="noopener noreferrer">Curve448</a>（Curve448-Goldilocks）是一种非扭曲 Edwards 曲线，它的方程定义如下：</p><p>$$
x^2 + y^2 = 1 - 39081 x^2 y^2
$$</p><p>其被定义在有限域 $\mathbb {F} _{p}$ 上，$p = 2448 - 2224 - 1$，其他域参数：</p><ul><li>阶 <code>n = 2446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d</code></li><li>辅助因子 <code>h = 4</code></li></ul><p>与 Curve25519 一样，Curve448 也等价于前面给出的 Weierstrass 形式，选择 Edwards 形式主要是因为它能显著提升性能。</p><p>Curve448 提供 222.8 位的安全强度。
Curve448 的私钥为 446 位，通常编码为 448 位整数（56 个字节，112 个十六进制数字）。
公钥也被编码为 448 位整数。</p><p>基于 Curve448 派生出了名为 <a href=https://tools.ietf.org/html/rfc7748#section-5 target=_blank rel="noopener noreferrer">X448</a> 的 ECDH 算法，以及基于 EdDSA 的高速数字签名算法 <a href=https://tools.ietf.org/html/rfc8032#section-5.2 target=_blank rel="noopener noreferrer">Ed448</a>.</p><h5 id=该选择哪种椭圆曲线 class=headerLink><a href=#%e8%af%a5%e9%80%89%e6%8b%a9%e5%93%aa%e7%a7%8d%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf class=header-mark></a>该选择哪种椭圆曲线</h5><p>首先，Bernstein 的 SafeCurves 标准列出了符合一组 ECC 安全要求的安全曲线，可访问 <a href=https://safecurves.cr.yp.to target=_blank rel="noopener noreferrer">https://safecurves.cr.yp.to</a> 了解此标准。</p><p>此外对于我们前面介绍的 Curve448 与 Curve25519，可以从性能跟安全性方面考量：</p><ul><li>要更好的性能，可以接受弱一点的安全性：选择 Curve25519</li><li>要更好的安全性，可以接受比 Curve25519 慢 3 倍的计算速度：选择 Curve448</li></ul><p>如果你的应用场景中暂时还很难用上 Curve448/Curve25519，你可以考虑一些应用更广泛的其他曲线，但是一定要遵守如下安全规范：</p><ul><li>模数 p 应该至少有 256 位<ul><li>比如 <code>secp224k1</code> <code>secp192k1</code> 啥的就可以扫进历史尘埃里了</li></ul></li><li>暂时没有想补充的，可以参考 <a href=https://safecurves.cr.yp.to target=_blank rel="noopener noreferrer">https://safecurves.cr.yp.to</a></li></ul><p>目前在 TLS 协议以及 JWT 签名算法中，目前应该最广泛的椭圆曲线仍然是 NIST 系列：</p><ul><li><code>P-256</code>: 到目前为止 P-256 应该仍然是应用最为广泛的椭圆曲线<ul><li>在 openssl 中对应的名称为 <code>prime256v1</code></li></ul></li><li><code>P-384</code><ul><li>在 openssl 中对应的名称为 <code>secp384r1</code></li></ul></li><li><code>P-521</code><ul><li>在 openssl 中对应的名称为 <code>secp521r1</code></li></ul></li></ul><p>但是我们也看到 Curve25519 正在越来越流行，因为美国政府有前科，NIST 标准被怀疑可能有后门，目前很多人都在推动使用 Curve25519 等社区方案取代掉 NIST 标准曲线。</p><p>对于 openssl，如下命令会列出 openssl 支持的所有曲线：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>openssl ecparam -list_curves
</span></span></code></pre></td></tr></table></div></div><h3 id=ecies---集成加密方案 class=headerLink><a href=#ecies---%e9%9b%86%e6%88%90%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88 class=header-mark></a>ECIES - 集成加密方案</h3><p>在文章开头我们已经介绍了集成加密方案 (IES)，它在密钥封装机制（KEM）的基础上，添加了密钥派生算法 KDF、消息认证算法 MAC 等其他密码学算法以达成我们对消息的安全性、真实性、完全性的需求。</p><p>而 ECIES 也完全类似，是在 ECC + 对称加密算法的基础上，添加了许多其他的密码学算法实现的。</p><p>ECIES 是一个加密框架，而不是某种固定的算法。它可以通过插拔不同的算法，形成不同的实现。
比如「secp256k1 + Scrypt + AES-GCM + HMAC-SHA512」。</p><p>大概就介绍到这里吧，后续就请在需要用到时自行探索相关的细节咯。</p><h2 id=参考 class=headerLink><a href=#%e5%8f%82%e8%80%83 class=header-mark></a>参考</h2><ul><li><a href=https://github.com/nakov/Practical-Cryptography-for-Developers-Book target=_blank rel="noopener noreferrer">Practical-Cryptography-for-Developers-Book</a></li><li><a href=https://dev.to/techschoolguru/a-complete-overview-of-ssl-tls-and-its-cryptographic-system-36pd target=_blank rel="noopener noreferrer">A complete overview of SSL/TLS and its cryptographic system</a></li><li><a href=https://www.oscca.gov.cn/sca/zxfw/2017-04/24/content_1011711.shtml target=_blank rel="noopener noreferrer">密码发展史之近现代密码 - 中国国家密码管理局</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc6090 target=_blank rel="noopener noreferrer">RFC6090 - Fundamental Elliptic Curve Cryptography Algorithms</a></li><li><a href=https://security.stackexchange.com/questions/78621/which-elliptic-curve-should-i-use target=_blank rel="noopener noreferrer">Which elliptic curve should I use?</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-13</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=# onclick=return!1 title="分享到 Twitter" data-sharer=twitter data-url=https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/ data-title="写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC" data-via=ryan4yin data-hashtags=Cryptography,密码学,非对称加密,安全,RSA,ECC><i class="fab fa-twitter fa-fw"></i></a><a href=# onclick=return!1 title="分享到 Facebook" data-sharer=facebook data-url=https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/ data-hashtag=Cryptography><i class="fab fa-facebook-square fa-fw"></i></a><a href=# onclick=return!1 title="分享到 Reddit" data-sharer=reddit data-url=https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/cryptography/>Cryptography</a>,&nbsp;<a href=/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/>密码学</a>,&nbsp;<a href=/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/>非对称加密</a>,&nbsp;<a href=/tags/%E5%AE%89%E5%85%A8/>安全</a>,&nbsp;<a href=/tags/rsa/>RSA</a>,&nbsp;<a href=/tags/ecc/>ECC</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/practical-cryptography-basics-6-symmetric-key-ciphers/ class=prev rel=prev title="写给开发人员的实用密码学（六）—— 对称密钥加密算法"><i class="fas fa-angle-left fa-fw"></i>写给开发人员的实用密码学（六）—— 对称密钥加密算法</a>
<a href=/posts/about-tls-cert/ class=next rel=next title="写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><a href=https://www.foreverblog.cn/ target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png alt style=width:auto;height:15px;margin-bottom:5px></a> <a href=https://www.foreverblog.cn/go.html target=_blank><img src=https://img.foreverblog.cn/wormhole_3.gif alt style=width:auto;height:24px title=穿梭虫洞-随机访问十年之约友链博客></a></div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.108.0">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://thiscute.world/ target=_blank rel="noopener noreferrer">ryan4yin</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4V93QVSNFW",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-4V93QVSNFW" async></script></div><div class=pjax-assets><script type=text/javascript>window.config={code:{maxShownLines:100},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"ryan4yin/thiscute.world"}},data:{"desktop-header-typeit":"This Cute World","mobile-header-typeit":"This Cute World"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"747LJ10EI7",algoliaIndex:"ryan-space",algoliaSearchKey:"658db5f2bf056f83458cacf5dd58ec80",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},sharerjs:!0,typeit:{cursorChar:null,cursorSpeed:null,data:{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/utterances.min.js defer></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript></div></body></html>